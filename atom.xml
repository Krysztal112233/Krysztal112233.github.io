<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Krysztal的书桌</title>
  
  <subtitle>嗯？看来被找到了。欢迎~</subtitle>
  <link href="https://blog.krysztal.dev/atom.xml" rel="self"/>
  
  <link href="https://blog.krysztal.dev/"/>
  <updated>2024-09-22T11:36:37.485Z</updated>
  <id>https://blog.krysztal.dev/</id>
  
  <author>
    <name>Krysztal</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>农夫乐事 FaQ 启示</title>
    <link href="https://blog.krysztal.dev/2024/09/22/%E5%86%9C%E5%A4%AB%E4%B9%90%E4%BA%8BFaQ%E5%90%AF%E7%A4%BA/"/>
    <id>https://blog.krysztal.dev/2024/09/22/%E5%86%9C%E5%A4%AB%E4%B9%90%E4%BA%8BFaQ%E5%90%AF%E7%A4%BA/</id>
    <published>2024-09-22T18:13:37.000Z</published>
    <updated>2024-09-22T11:36:37.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>农夫乐事作为一个 Minecraft 模组，以较少的物品量和丰富的玩法夺得了众多玩家的喜爱与欢迎。这到底是为什么？其实答案都藏在 Discord 的 FaQ 里了。</p><span id="more"></span><blockquote><p>🌽 Why won't you add X, Y or Z crop? Why just these four crops?</p><p>My goal with the new crops was to open doors for new recipes using Minecraft's existing ingredients, while avoiding clutter. Cabbage, Tomato, Onion and Rice are very versatile ingredients for many recipes, like salads, sandwiches, garnishes, stuffings and such.</p><p>This isn't to say that more crops are out of the question, though! I would love to add more (even ones not fully related to food), but simply haven't found ones that are as versatile as these four yet. Who knows!</p><p>🌽 为什么不添加 X，Y 或者 Z 作物？为什么只有 4 种作物？</p><p>我添加新作物的目标是利用 Minecraft 已有的配方打开新的大门，并且避免杂乱无章。卷心菜，番茄，洋葱和大米是可以用于制作很多食品的常见食材，例如沙拉，三明治，装饰品和馅料等等。</p><p>但这并不是说不可能有更多的作物！我很想添加更多作物（甚至是与食物不完全相关的作物），但目前还没有找到像这四种作物一样用途广泛的作物。谁知道呢？</p></blockquote><p>这一点阐述了一个产品的功能，它应该尽可能地有用，并且能整合用户的习惯而不是创建一大批无用的功能使得整个产品看起来十分混乱。添加新的功能要有节制地添加，而不是毫无节制地想起什么功能添加什么功能。</p><blockquote><p>🪵 Any reason why we need to strip logs on a Cutting Board to get Tree Bark? Why not on the logs directly?</p><p>Not all players will be bothering with FD on modpacks or servers, and players frequently strip logs to decorate their builds.</p><p>If I made all logs give bark when stripped, it would rapidly clutter a player's inventory with an item they might not want to have, frustrating them. Hence why the Cutting Board is the route for it: to make it opt-in.</p><p>🪵 为什么要在切板上剥原木才能得到树皮？为什么不直接在原木上剥？</p><p>并不是所有玩家都会在整合包或服务器上使用农夫乐事，而且玩家经常剥离原木来装饰自己的建筑。</p><p>如果我让所有原木在剥离时都能产生树皮，那么玩家的库存中就会迅速塞满他们可能不想拥有的物品，从而使他们感到沮丧。因此，“砧板”才是实现这一目标的途径：让玩家选择使用。</p></blockquote><p>给用户选择自由，避免帮用户做了用户不喜欢的事。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;农夫乐事作为一个 Minecraft 模组，以较少的物品量和丰富的玩法夺得了众多玩家的喜爱与欢迎。这到底是为什么？其实答案都藏在 Discord 的 FaQ 里了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust 实现拓展系统札记</title>
    <link href="https://blog.krysztal.dev/2024/09/18/%E4%BD%BF%E7%94%A8-Rust-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%B3%BB%E7%BB%9F%E6%9C%AD%E8%AE%B0/"/>
    <id>https://blog.krysztal.dev/2024/09/18/%E4%BD%BF%E7%94%A8-Rust-%E5%AE%9E%E7%8E%B0%E6%8B%93%E5%B1%95%E7%B3%BB%E7%BB%9F%E6%9C%AD%E8%AE%B0/</id>
    <published>2024-09-18T00:26:23.000Z</published>
    <updated>2024-09-22T11:36:37.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Rust 在生产上的优势十分明显了，极高的性能和极致的资源体验。</p><p>但是对于我而言，总是觉得少了些什么——拓展系统。</p><span id="more"></span><h2 id="方案选择">方案选择</h2><p>与我熟悉的 JVM 平台不同，JVM 平台通过在虚拟机内运行时链接的方式实现稳定的 ABI。这是稳定性和可控性极高的实践，很符合 JVM 的特性。</p><p>而 Rust 所属的 Native 平台需要通过系统的链接器——比如 <code>ld</code> 等——这涉及到平台提供的<strong><em>动态链接</em></strong>功能。</p><p>但是除此之外，在 Rust 生态里，甚至是新的编程语言生态里，产生了一种新的拓展架构——加载 <a href="https://webassembly.org/">wasm</a> 文件作为拓展。</p><p>综上所述，我们有两种可以考虑的架构：</p><ul><li>原生平台拓展：通过加载 <code>so</code>、<code>dylib</code>、<code>dll</code> 等动态库来实现拓展</li><li>wasm 平台拓展：通过加载 <code>wasm</code> 文件到 wasm 运行时，通过运行时获取拓展能力</li></ul><p>接下来，我们将深入了解两种插件平台的实现上的区别。</p><h2 id="原生平台">原生平台</h2><p>原生平台实现需要依赖编译器的 ABI 稳定，但是新时代的原生语言（Rust，Go，Crystal 等）基本上都没有稳定的 ABI，<strong><em>所以需要依赖 C 的稳定的 ABI 来曲线救国</em></strong>。</p><p>但有个例外，Rust 平台存在 <a href="https://crates.io/crates/abi_stable"><code>abi_stable</code></a> 这个 crate，因此我们也可以通过它来实现。</p><p>也就是说，对于原生平台，我们现在有了两种选择：</p><ul><li><a href="https://crates.io/crates/libloading"><code>libloading</code></a>：轻易加载动态库</li><li><a href="https://crates.io/crates/abi_stable"><code>abi_stable</code></a>：安全的 Rust FFI 包装</li></ul><p><code>libloading</code> 的原理十分简单粗暴，就是利用链接器查找符号检查是否符合目标期望，如果期望则包装成为 Rust 的对象实例，方便调用。这也是标准的原生插件加载流程。</p><p><code>abi_stable</code> 则使用分析修改 <a href="https://github.com/rust-lang/miri">miri</a> 等方式固化 ABI，并且实现了 Rust 标准库包装使得标准库 ABI 也进一步稳定，再继承 <code>libloading</code> 的流程使得实现安全的 Rust FFI 拓展。</p><p>请参照我实现的 <a href="https://github.com/Krysztal112233/eloader">eloader</a> 项目来理解 <code>abi_stable</code> 的具体流程和用法，该库实现了一套很简单基础的拓展加载器。</p><h2 id="wasm-平台">wasm 平台</h2><p>TODO</p><h2 id="限制">限制？</h2><p>和 JVM 不同，实现原生平台的拓展系统无法直接访问宿主的诸如静态变量等字段，这是处于安全性考虑，也是加载机制导致的。</p><p>原生平台上，一个程序的内存地址实际上是虚拟内存地址，也就是说是“假”的内存地址。</p><p>并且，对于一个变量或者函数而言，一旦被 <code>static</code> 修饰，那么它就是模块私有的，这和 JVM 平台的逻辑完全不一样。</p><p>或者说，JVM 的 <code>ClassLoader</code> 就是一个巨大的模块，因此可以肆无忌惮的访问 <code>static</code> 成员——因为他们就在同一个模块里。</p><p>也就是说如果要访问这些变量或者函数，需要一个中间人作为其中的代理——例如上下文设计模式，传入已经重定位完成的 <code>Context</code> 结构体，其中包含各种对静态的调用，则可以间接实现这点，并且 Nginx 和 Apache 等实现了拓展系统的宿主均使用这种模式。</p><h2 id="资源卸载">资源卸载</h2><p>我们先认知一下资源到底是什么：</p><ul><li>文件句柄</li><li>网络句柄</li><li>事件资源</li><li>...</li></ul><p>资源卸载是一种很难解决的问题——因为没有办法确定加载内容到底加载了什么资源，而且无法中断当前的状态实现卸载。</p><p>如果使用智能指针，例如引用计数等，实际上不能解决这个问题。资源卸载涉及到外部和系统的代数效应，程序内只能处理局部的代数效应。</p><h3 id="理想环境">理想环境</h3><ul><li>拓展向宿主申请资源句柄，不自己使用任何资源句柄</li><li>宿主重载拓展的时候会暂停当前任务，不再处理，然后等待拓展释放资源句柄</li><li>资源句柄释放完毕，宿主卸载所有拓展</li><li>卸载完毕，重新加载</li></ul><figure><img src="resource.svg" alt="" /><figcaption>resource</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rust 在生产上的优势十分明显了，极高的性能和极致的资源体验。&lt;/p&gt;
&lt;p&gt;但是对于我而言，总是觉得少了些什么——拓展系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/tags/%E6%8D%A3%E9%BC%93/"/>
    
  </entry>
  
  <entry>
    <title>遗传学定律的代码实现</title>
    <link href="https://blog.krysztal.dev/2024/08/31/%E9%81%97%E4%BC%A0%E5%AD%A6%E5%AE%9A%E5%BE%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.krysztal.dev/2024/08/31/%E9%81%97%E4%BC%A0%E5%AD%A6%E5%AE%9A%E5%BE%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-08-31T18:02:59.000Z</published>
    <updated>2024-09-22T11:36:37.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note note-success">            <p>因为最近要实现这方面的功能，所以写篇文章复习一下。</p>          </div><span id="more"></span><h2 id="遗传学三大定律">遗传学三大定律</h2><p>在深入探讨遗传学的代码实现之前，需要清楚遗传学的三大定律</p><h3 id="基因分离定律孟德尔第一定律">基因分离定律（孟德尔第一定律）</h3><p>基因作为遗传单位在体细胞中是成双的，它在遗传上具有高度的独立性。</p><p>因此，在减数分裂的配子形成过程中，成对的基因在杂种细胞中能够彼此互不干扰，独立分离，通过基因重组在子代继续表现各自的作用。</p><p>这一规律从理论上说明了生物界由于杂交和分离所出现的变异的普遍性。</p><figure><img src="第一定律.png" alt="" /><figcaption>第一定律</figcaption></figure><h3 id="基因自由组合定律孟德尔第二定律">基因自由组合定律（孟德尔第二定律）</h3><p>一对染色体上的等位基因与另一对染色体上的等位基因的分离或组合是彼此间互不干扰的，各自独立地分配到配子中去。</p><figure><img src="第二定律.svg" alt="" /><figcaption>第二定律</figcaption></figure><h3 id="基因的连锁和交换定律">基因的连锁和交换定律</h3><p>一般而言，两对等位基因相距越远，发生交换的机会越大，即交换率越高；反之，相距越近，交换率越低。因此，交换率可用来反映同一染色体上两个基因之间的相对距离</p><p>以基因重组率为 1% 时两个基因间的距离记作 1 <strong><em>厘摩</em></strong>（<span class="math inline">\(centimorgan, cM\)</span>）</p><h2 id="代码实现">代码实现</h2><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note note-success&quot;&gt;
            &lt;p&gt;因为最近要实现这方面的功能，所以写篇文章复习一下。&lt;/p&gt;
          &lt;/div&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>EN:The Journey of Rust and Procps</title>
    <link href="https://blog.krysztal.dev/2024/08/20/EN_The-Journey-of-Rust-and-Procps/"/>
    <id>https://blog.krysztal.dev/2024/08/20/EN_The-Journey-of-Rust-and-Procps/</id>
    <published>2024-08-20T20:43:12.000Z</published>
    <updated>2024-09-22T11:36:37.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Hi, I'm Krysztal Huang, a contributor to Debian's <code>uutils/procps</code>.</p><span id="more"></span><p>I'm thrilled to have had the opportunity to participate in GSoC 2024, contributing to the uutils project and gaining a wealth of knowledge and skills along the way. :)</p><p>The Debian and uutils communities are incredibly welcoming, which has been fantastic. I've been using Debian as my primary operating system for about eight years now, drawn to its stability. I frequently rely on Debian for my personal services and various projects.</p><h2 id="the-procps-project">The procps project</h2><p>The most widely used implementation of <code>procps</code> is the one under <strong>GPLv3</strong>, the <a href="https://gitlab.com/procps-ng/procps">procps-ng</a> project. It provides a set of tools for system information statistics that have been used for many years and have served well. However, it is written in <strong>C</strong> and licensed under <strong>GPLv3</strong>.</p><p>This project has been in use for over thirty years, and its code is not as <strong><em>open</em></strong> as it could be because of its license. Moreover, it will likely remain in our operating systems for the foreseeable future.</p><p>But <code>procps</code> and C are <strong>getting old</strong>. Younger developers tend to prefer newer programming languages like Rust. As a result, <code>procps</code> may rely on the previous generation for maintenance, while the younger generation may have less interest in it due to their unfamiliarity with C. Consequently, those <strong>wanting to contribute</strong> may struggle to effectively fix issues.</p><h2 id="the-cves-and-rust">The CVEs and Rust</h2><p>Rust offers excellent memory safety and performance. Many CVEs associated with the original <code>procps</code> are related to memory safety issues (e.g., buffer overflows):</p><ul><li><a href="https://security-tracker.debian.org/tracker/CVE-2018-1126">CVE-2018-1126</a></li><li><a href="https://security-tracker.debian.org/tracker/CVE-2018-1125">CVE-2018-1125</a></li></ul><p>...and others.</p><p>However, with Rust, these issues are caught at compile time, thanks to its ownership system.</p><h2 id="so...">So...?</h2><p>I'm working on rewriting <code>procps</code> under the <a href="https://github.com/uutils">uutils</a> organization. The new implementation, simply called <a href="https://github.com/uutils/procps">procps</a>, has taught me a lot: from understanding the <code>/proc</code> pseudo-filesystem to the differences between *NIX (and *NIX-like) systems.</p><p>The initial implementation of uutils <code>procps</code> was focused on the Linux platform. However, to support the broader *NIX platform, including macOS and FreeBSD, it's important to address the subtle differences in implementation across these operating systems. As of now, the uutils <code>procps</code> <strong>does not support</strong> macOS and FreeBSD.</p><p>Relevant issues:</p><ul><li><a href="https://github.com/uutils/procps/issues/162">procps#162</a></li><li><a href="https://github.com/uutils/procps/issues/179">procps#179</a></li></ul><p>The ultimate goal for uutils <code>procps</code> is to support both *NIX and Windows platforms. However, the threading models for Windows and *NIX platforms differ significantly, necessitating the abstraction of these models into a more general one.</p><p>Most importantly, uutils' <code>procps</code> implementation is licensed using the MIT license, which is a very loose open source license. Meaning that uutils' procps has virtually no restrictions from source distribution to use.</p><h2 id="what-did-i-do">What did I do?</h2><p>I've implemented the basic parts of some commands and they now run the most basic functions.</p><p>Relevant prs:</p><ul><li><a href="https://github.com/uutils/procps/pull/95">pgrep</a></li><li><a href="https://github.com/uutils/procps/pull/112">pidof</a></li><li><a href="https://github.com/uutils/procps/pull/167">pidwait</a></li><li><a href="https://github.com/uutils/procps/pull/133">ps</a></li><li><a href="https://github.com/uutils/procps/pull/42">slabtop</a></li><li><a href="https://github.com/uutils/procps/pull/189">top</a></li></ul><hr /><p>Thanks to my mentors and, without your help, I probably wouldn't have fit into the community and development as well as I have :)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi, I&#39;m Krysztal Huang, a contributor to Debian&#39;s &lt;code&gt;uutils/procps&lt;/code&gt;.&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文章" scheme="https://blog.krysztal.dev/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>ZH:Rust 与 Procps 之旅</title>
    <link href="https://blog.krysztal.dev/2024/08/20/ZH_Rust%E4%B8%8EProcps%E4%B9%8B%E6%97%85/"/>
    <id>https://blog.krysztal.dev/2024/08/20/ZH_Rust%E4%B8%8EProcps%E4%B9%8B%E6%97%85/</id>
    <published>2024-08-20T20:43:12.000Z</published>
    <updated>2024-09-22T11:36:37.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>大家好，我是 Krysztal Huang，Debian 的 <code>uutils/procps</code> 贡献者之一。</p><span id="more"></span><p>很高兴能参与 GSoC 2024，为 uutils 项目做出贡献，并在此过程中学到了许多有趣的知识和技能。:)</p><p>Debian 和 uutils 社区非常友好，这是非常棒的。我使用 Debian 作为我的主要操作系统已有大约八年的时间，主要是被它的稳定性所吸引。我经常依赖 Debian 来支持我的个人服务和各种项目。</p><h2 id="procps-项目">procps 项目</h2><p>最广泛使用的 <code>procps</code> 实现是 <strong>GPLv3</strong> 许可下的 <a href="https://gitlab.com/procps-ng/procps">procps-ng</a> 项目。它提供了一组用于系统信息统计的工具，多年来一直被广泛使用，并且表现良好。然而，它是用 <strong>C</strong> 语言编写的，并采用 <strong>GPLv3</strong> 许可。</p><p>该项目已经使用了三十多年，但因为许可证的原因，其<strong><em>自由性</em></strong>不足。此外，它可能还会在我们的操作系统中继续存在很长时间。</p><p>但 <code>procps</code> 和 C 语言已经<strong>逐渐老化</strong>。年轻的开发者更倾向于使用像 Rust 这样的新编程语言。因此，<code>procps</code> 可能会依赖上一代开发者来维护，而年轻一代由于对 C 语言不熟悉，可能对其兴趣不大。因此，<strong>想要参与开发</strong>的年轻人可能无法有效地修复问题。</p><h2 id="cve-与-rust">CVE 与 Rust</h2><p>Rust 提供了出色的内存安全性和性能。原始 <code>procps</code> 的许多 CVE 都与内存安全问题有关（例如，缓冲区溢出）：</p><ul><li><a href="https://security-tracker.debian.org/tracker/CVE-2018-1126">CVE-2018-1126</a></li><li><a href="https://security-tracker.debian.org/tracker/CVE-2018-1125">CVE-2018-1125</a></li></ul><p>……等等。</p><p>然而，在 Rust 中，得益于它的所有权系统，这些问题在编译时就能被捕获。</p><h2 id="所以">所以……？</h2><p>我正在<a href="https://github.com/uutils"><strong>uutils</strong></a>组织下重写 <code>procps</code>。新的实现被简单地命名为 <a href="https://github.com/uutils/procps"><strong>procps</strong></a>，在这个过程中我学到了很多：从理解 <code>/proc</code> 伪文件系统到了解 *NIX（及 *NIX 类）系统之间的差异。</p><p>uutils <code>procps</code> 的初始实现主要集中在 Linux 平台。然而，为了支持更广泛的 *NIX 平台，包括 macOS 和 FreeBSD，我们必须处理这些操作系统在实现上的细微差异。截至目前，uutils <code>procps</code> <strong>不支持</strong> macOS 和 FreeBSD。</p><p>相关问题：</p><ul><li><a href="https://github.com/uutils/procps/issues/162">procps#162</a></li><li><a href="https://github.com/uutils/procps/issues/179">procps#179</a></li></ul><p>uutils <code>procps</code>的最终目标是同时支持 *NIX 和 Windows 平台。然而，Windows 和 *NIX 平台的线程模型差异显著，因此有必要将这些线程模型抽象为一个更通用的模型。</p><p>最重要的是，uutils 的 <code>procps</code> 实现使用 MIT 协议进行授权，这是一款十分宽松的开源协议。意味着 uutils 的 <code>procps</code> 几乎没有任何限制，从源码分发到使用。</p><h2 id="我做了什么">我做了什么？</h2><p>我实现了一些命令的基本部分，它们现在可以运行最基本的功能。</p><p>相关 PR：</p><ul><li><a href="https://github.com/uutils/procps/pull/95">pgrep</a></li><li><a href="https://github.com/uutils/procps/pull/112">pidof</a></li><li><a href="https://github.com/uutils/procps/pull/167">pidwait</a></li><li><a href="https://github.com/uutils/procps/pull/133">ps</a></li><li><a href="https://github.com/uutils/procps/pull/42">slabtop</a></li><li><a href="https://github.com/uutils/procps/pull/189">top</a></li></ul><hr /><p>感谢我的导师们，没有你们的帮助，我可能无法如此顺利地融入社区和开发中。:)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是 Krysztal Huang，Debian 的 &lt;code&gt;uutils/procps&lt;/code&gt; 贡献者之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="文章" scheme="https://blog.krysztal.dev/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用 debootstrap 与 schroot 构建一个纯净环境</title>
    <link href="https://blog.krysztal.dev/2024/07/12/%E4%BD%BF%E7%94%A8debootstrap%E4%B8%8Eschroot%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%AF%E5%87%80%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.krysztal.dev/2024/07/12/%E4%BD%BF%E7%94%A8debootstrap%E4%B8%8Eschroot%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%AF%E5%87%80%E7%8E%AF%E5%A2%83/</id>
    <published>2024-07-12T18:42:16.000Z</published>
    <updated>2024-09-22T11:36:37.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>chroot</code> 在系统工程和系统架构方面有很重大的作用，可以创建一个不是那么隔离的纯净环境，用于调试一些可能会污染宿主机环境的程序是十分方便的。</p><span id="more"></span><h2 id="为什么不使用虚拟机">为什么不使用虚拟机？</h2><p>使用虚拟机说实话挺不方便的，如果使用虚拟机的话需要单独开一片磁盘空间和各种配置。</p><p>很多环境下不需要如虚拟机那样的隔离空间（例如软件包构建与打包等），在这种环境下使用 <code>chroot</code> 就可以了。</p><p>事实上，在 Debian 的官方打包流程里也推荐使用 <code>chroot</code> 的派生工具 <code>schroot</code> 来打包程序<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DebianWiki: SchrootPackageing](https://wiki.debian.org/SchrootPackaging)">[0]</span></a></sup>，这样打包出来的程序可以认为在所有 Debian <strong><em>基础系统</em></strong>上是幂等的。</p><h2 id="下一步......">下一步......</h2><p>我们接下来制作的，DebianWiki 里称之为 <em>Caged Debian</em>.</p><figure><img src="https://wiki.debian.org/SchrootPackaging?action=AttachFile&amp;do=get&amp;target=debian-cage.png" alt="" /><figcaption>Caged Debian</figcaption></figure><p>首先需要安装两个必要软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install debootstrap schroot<br></code></pre></td></tr></table></figure><p>然后变更 schroot 的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /etc/schroot/schroot.conf /etc/schroot/schroot.conf.old<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano /etc/schroot/schroot.conf<br></code></pre></td></tr></table></figure><p>接下来填入这些内容，填的时候记得改用户名</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[unstable-amd64]<br>description=debian unstable amd64<br>type=directory<br>directory=/srv/chroot/unstable-amd64<br>users=&lt;YOUR_NAME&gt;<br>root-groups=root<br>preserve-environment=true<br></code></pre></td></tr></table></figure><p>在完成上一步后，就可以开始准备安装了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /srv/chroot/unstable-amd64<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debootstrap --arch amd64 unstable /srv/chroot/unstable-amd64 https://deb.debian.org/debian<br></code></pre></td></tr></table></figure><p>请注意，如果你使用的底层系统版本出现在 Debian UsrMerge 之前那么你只能使用本文发出时的 Debian Stable （Debian12）版本，否则你会遇到很多奇怪的问题比如说无法解压。</p><p>完成这一步后需要准备一下 Caged Debian：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chroot /srv/chroot/unstable-amd64<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo proc /proc proc defaults 0 0 &gt;&gt; /etc/fstab<br></code></pre></td></tr></table></figure><p>在上一步是写的挂载 <code>/proc</code> 虚拟文件系统，这一步必须要做。</p><p>然后就可以进入环境了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">schroot -c unstable-amd64 -u root<br></code></pre></td></tr></table></figure><!-- reference --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.debian.org/SchrootPackaging">DebianWiki: SchrootPackageing</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;chroot&lt;/code&gt; 在系统工程和系统架构方面有很重大的作用，可以创建一个不是那么隔离的纯净环境，用于调试一些可能会污染宿主机环境的程序是十分方便的。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GPG添加新的用户信息</title>
    <link href="https://blog.krysztal.dev/2024/05/29/GPG%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://blog.krysztal.dev/2024/05/29/GPG%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/</id>
    <published>2024-05-29T19:03:50.000Z</published>
    <updated>2024-09-22T11:36:37.479Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近一段时间我决定启用 <code>krysztal.huang@outlook.com</code> 这个邮箱地址作为我的工作邮箱，于是我把 GitHub 等都换成了这个，但我的 GPG 就炸了。</p><span id="more"></span><p>所以需要找办法向 GPG 更新或者添加用户信息，总不可能删掉信息重新做 GPG 吧？</p><h2 id="选择编辑的-key">选择编辑的 Key</h2><p>这里假设你导入了你的主密钥，因为有可能你像我一样用的是子密钥</p><p>我发现也可以通过指定邮箱的方式来编辑 key，那就用邮箱方式吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gpg --edit-key suibing112233@outlook.com<br></code></pre></td></tr></table></figure><p>进入后就可以开始编辑 Key 了，本次目的主要是新增不是删除，因为老的邮箱我也在用</p><p>只不过以后工作邮箱就变了</p><h2 id="新增-gpg-用户信息">新增 GPG 用户信息</h2><p>在 GPG 的交互终端里输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">gpg&gt; </span><span class="language-bash">adduid</span><br></code></pre></td></tr></table></figure><p>然后按照他提示的信息填入，这样新的信息就完成了</p><p>如果旧的信息需要被删除的话需要有额外的步骤，用 <code>deluid</code> 命令即可</p><p>完成后输入 <code>save</code> 命令退出 GPG 的交互终端即可</p><h2 id="接下来">接下来？</h2><p>接下来需要做的，就是重新导出密钥，重新之作智能卡，重新上传公钥到 KeyServer</p><p>以上步骤参照我的这篇文章即可 <a href="https://blog.krysztal.dev/2022/06/22/GPG%E7%89%A9%E7%90%86%E5%AF%86%E9%92%A5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%BF%81%E7%A7%BB/">GPG 物理密钥的安装与密钥的迁移</a></p><p>对了，还得更新 GitHub 这些地方的公钥，他们不是自动更新的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一段时间我决定启用 &lt;code&gt;krysztal.huang@outlook.com&lt;/code&gt; 这个邮箱地址作为我的工作邮箱，于是我把 GitHub 等都换成了这个，但我的 GPG 就炸了。&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/"/>
    
    <category term="杂文" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E6%9D%82%E6%96%87/"/>
    
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/tags/%E6%8D%A3%E9%BC%93/"/>
    
  </entry>
  
  <entry>
    <title>GSoC2024 笔记：使用 Rust 重新实现 procps</title>
    <link href="https://blog.krysztal.dev/2024/03/28/GSoC2024-notes/"/>
    <id>https://blog.krysztal.dev/2024/03/28/GSoC2024-notes/</id>
    <published>2024-03-28T23:41:01.000Z</published>
    <updated>2024-09-22T11:36:37.480Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><code>procps</code> 是一套用于收集统计系统信息的套件，也指代一套访问 <code>/proc</code> 文件系统的 API。uutils 的 procps 是用 Rust 重新实现的，而这正好是本次 GSoC 的提案内容。</p><span id="more"></span><p>文章总体很长，请使用右侧 <em><strong>TOC</strong></em> 来跳转</p><h2 id="free-命令"><code>free</code> 命令</h2><p>用于显示系统中已用和未用内存空间</p><h3 id="文件系统">文件系统</h3><p><code>free</code> 命令通过访问 <code>/proc/meminfo</code> 假（pseudo）文件系统来获取原始信息</p><p>对于一个该假文件系统文件的典型输出为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ cat /proc/meminfo<br>MemTotal:       32273056 kB<br>MemFree:          434940 kB<br>MemAvailable:   21037048 kB<br>Buffers:              32 kB<br>Cached:         20893812 kB<br>SwapCached:            0 kB<br>Active:         13078828 kB<br>Inactive:       16008968 kB<br>Active(anon):    4430756 kB<br>Inactive(anon):  4009712 kB<br>Active(file):    8648072 kB<br>Inactive(file): 11999256 kB<br>Unevictable:         128 kB<br>Mlocked:             128 kB<br>SwapTotal:             0 kB<br>SwapFree:              0 kB<br>Zswap:                 0 kB<br>Zswapped:              0 kB<br>Dirty:              2880 kB<br>Writeback:             0 kB<br>AnonPages:       7908776 kB<br>Mapped:          1515536 kB<br>Shmem:            246428 kB<br>KReclaimable:     417148 kB<br>Slab:             734004 kB<br>SReclaimable:     417148 kB<br>SUnreclaim:       316856 kB<br>KernelStack:       40940 kB<br>PageTables:        79788 kB<br>SecPageTables:         0 kB<br>NFS_Unstable:          0 kB<br>Bounce:                0 kB<br>WritebackTmp:          0 kB<br>CommitLimit:    16136528 kB<br>Committed_AS:   20790660 kB<br>VmallocTotal:   34359738367 kB<br>VmallocUsed:       92816 kB<br>VmallocChunk:          0 kB<br>Percpu:            13312 kB<br>HardwareCorrupted:     0 kB<br>AnonHugePages:   1038336 kB<br>ShmemHugePages:        0 kB<br>ShmemPmdMapped:        0 kB<br>FileHugePages:         0 kB<br>FilePmdMapped:         0 kB<br>Unaccepted:            0 kB<br>HugePages_Total:       0<br>HugePages_Free:        0<br>HugePages_Rsvd:        0<br>HugePages_Surp:        0<br>Hugepagesize:       2048 kB<br>Hugetlb:               0 kB<br>DirectMap4k:     3882436 kB<br>DirectMap2M:    29063168 kB<br>DirectMap1G:           0 kB<br></code></pre></td></tr></table></figure><p>该输出的 <code>kB</code> 单位实际上为 <code>2^10</code> byte，也就是 <code>1kB = 1024B</code></p><h3 id="解析">解析</h3><p>解析时应当忽略最后的 <code>kB</code>，实际上解析应当只包含 <code>key</code> 和 <code>value</code> 而不包含末尾的单位</p><p>最后的解析结果类型应当是 <code>HashMap&lt;String, u64&gt;</code></p><h3 id="参考文献">参考文献</h3><ul><li><a href="https://manpages.debian.org/bookworm/procps/free.1.en.html">Debian Manpage: free</a></li><li><a href="https://docs.kernel.org/filesystems/proc.html">Kernel Archive: proc</a></li></ul><h2 id="tload-命令"><code>tload</code> 命令</h2><p><code>tload</code> 命令使用打印终端图形的方式向用户显示系统负载</p><h3 id="文件系统-1">文件系统</h3><p><code>tload</code> 命令使用 <code>/proc/loadavg</code> 作为信息源，该文件典型的内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ cat /proc/loadavg<br>3.06 2.61 2.77 8/2609 94056<br></code></pre></td></tr></table></figure><h3 id="解析-1">解析</h3><p>根据内核文档我们可以知道</p><blockquote><p>Load average of last 1, 5 &amp; 15 minutes;</p><p>number of processes currently runnable (running or on ready queue); total number of processes in system; last pid created. All fields are separated by one space except “number of processes currently runnable” and “total number of processes in system”, which are separated by a slash (‘/’). Example: 0.61 0.61 0.55 3/828 22084</p></blockquote><p>那么对于以上输出的例子，我们可以认为其意义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">3.06 2.61 2.77 8/2609 94056<br>|--| |--| |--| |----| |---|<br> |     |    |    |      |--- 最后创建的 PID<br> |     |    |    |---------- 当前可运行进程数/系统中总进程数<br> |     |    |--------------- 最近 15 分钟的平均负载<br> |     |-------------------- 最近 5 分钟的平均负载<br> |-------------------------- 最近 1 分钟的平均负载<br></code></pre></td></tr></table></figure><p>因此我们可以根据如上内容来设计数据结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LoadAvg</span> &#123;<br>    load1: <span class="hljs-type">u64</span>,<br>    load5: <span class="hljs-type">u64</span>,<br>    load15: <span class="hljs-type">u64</span>,<br>    runnable: <span class="hljs-type">u64</span>,<br>    total: <span class="hljs-type">u64</span>,<br>    last_pid: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考文献-1">参考文献</h3><ul><li><a href="https://manpages.debian.org/bookworm/procps/tload.1.en.html">Debian Manpage: tload</a></li><li><a href="https://docs.kernel.org/filesystems/proc.html">Kernel Archive: proc</a></li></ul><h2 id="vmstat-命令"><code>vmstat</code> 命令</h2><h2 id="slabtop-命令"><code>slabtop</code> 命令</h2><p>实时显示内核的 slab 缓存信息</p><h3 id="slab-是什么">slab 是什么</h3><p>slab 是一种 Linux 通用的内存分配器，其实现原理和工作原理不是本次 GSoC 的一部分，但可以通过 Kernel Document 获得相关的理论知识</p><h3 id="文件系统-2">文件系统</h3><p><code>slabtop</code> 使用 <code>/proc/slabinfo</code> 作为信息源，典型的输入如下(已作截断，并且已经对齐)</p><p>访问该文件需要 root 权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">slabinfo - version: 2.1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">name              &lt;active_objs&gt;   &lt;num_objs&gt;  &lt;objsize&gt;   &lt;objperslab&gt;    &lt;pagesperslab&gt;  : tunables   &lt;<span class="hljs-built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt;       : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br>nf_conntrack_expect 0               0           208         39              2               : tunables                0       0    0                    : slabdata      0      0      0<br>nf_conntrack        736             736         256         32              2               : tunables                0       0    0                    : slabdata     23     23      0<br>QIPCRTR             78              78          832         39              8               : tunables                0       0    0                    : slabdata      2      2      0<br>ovl_inode           585             585         720         45              8               : tunables                0       0    0                    : slabdata     13     13      0<br>kvm_vcpu            0               0           7288        4               8               : tunables                0       0    0                    : slabdata      0      0      0<br>x86_emulator        0               0           2656        12              8               : tunables                0       0    0                    : slabdata      0      0      0<br>fat_inode_cache     205             328         792         41              8               : tunables                0       0    0                    : slabdata      8      8      0<br></code></pre></td></tr></table></figure><p>其中第一行不作解析，声明 slabinfo 的版本</p><p>第二行声明每个元素的意义</p><p>将该输出换作表格形式后如下</p><table><thead><tr class="header"><th>name</th><th>active_objs</th><th>num_objs</th><th>objsize</th><th>objperslab</th><th>pagesperslab</th><th>tunables</th><th>limit</th><th>batchcount</th><th>sharedfactor</th><th>slabdata</th><th>active_slabs</th><th>num_slabs</th><th>sharedavail</th></tr></thead><tbody><tr class="odd"><td>nf_conntrack_expect</td><td>0</td><td>0</td><td>208</td><td>39</td><td>2</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>nf_conntrack</td><td>736</td><td>736</td><td>256</td><td>32</td><td>2</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>23</td><td>23</td><td>0</td></tr><tr class="odd"><td>QIPCRTR</td><td>78</td><td>78</td><td>832</td><td>39</td><td>8</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>2</td><td>2</td><td>0</td></tr><tr class="even"><td>ovl_inode</td><td>585</td><td>585</td><td>720</td><td>45</td><td>8</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>13</td><td>13</td><td>0</td></tr><tr class="odd"><td>kvm_vcpu</td><td>0</td><td>0</td><td>7288</td><td>4</td><td>8</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>0</td><td>0</td><td>0</td></tr><tr class="even"><td>x86_emulator</td><td>0</td><td>0</td><td>2656</td><td>12</td><td>8</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>0</td><td>0</td><td>0</td></tr><tr class="odd"><td>fat_inode_cache</td><td>205</td><td>328</td><td>792</td><td>41</td><td>8</td><td>tunables</td><td>0</td><td>0</td><td>0</td><td>slabdata</td><td>8</td><td>8</td><td>0</td></tr></tbody></table><h3 id="解析-2">解析</h3><p>根据以上的表格，我们可以发现该文件数据部分的格式实际上依赖第二行的 meta 格式，因此我们可以认为其格式如下</p><p><img src="./base.png" /></p><h4 id="分析-meta">分析 meta</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="hljs-built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br></code></pre></td></tr></table></figure><h4 id="最终结论">最终结论</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">SlabInfo</span> = <span class="hljs-type">Vec</span>&lt;HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">u64</span>&gt;&gt;;<br></code></pre></td></tr></table></figure><h3 id="参考文献-2">参考文献</h3><ul><li><a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html">Kernel Archive: slab</a></li></ul><h3 id="slabinfo-迭代记录"><code>slabinfo</code> 迭代记录</h3><p>slabinfo 文件总共有三个版本</p><ul><li>1.0 Present throughout the Linux 2.2.x kernel series.</li><li>1.1 Present in the Linux 2.4.x kernel series.</li><li>1.2 A format that was briefly present in the Linux 2.5 development series.</li><li>2.0 Present in Linux 2.6.x kernels up to and including Linux 2.6.9.</li><li>2.1 The current format, which first appeared in Linux 2.6.10.</li></ul><p>当前使用的版本为 2.1，而包含 <code>slabinfo2.1</code> 的内核为 2.6.10，第一次出现已经是接近 20 年前了，并且目前没有出现想要修改 <code>slabinfo</code> 文件的请求，因此认为该文件的内容和格式在较长时间内不会改变</p><h2 id="pgrep-命令"><code>pgrep</code> 命令</h2><p>通过名称来查找 PID</p><h3 id="文件系统-3">文件系统</h3><p><code>pgrep</code> 命令依赖于 <code>/proc/&lt;PID&gt;</code> 作为输入源，该部分文档见 <a href="https://docs.kernel.org/filesystems/proc.html#process-specific-subdirectories">Kernel Archive</a></p><p>pid 号在程序结束后会被删除。但有些清空 pid 会保留在/proc 文件系统里，这种情况一般是因为僵尸进程。</p><h3 id="解析-3">解析</h3><h4 id="进程启动时间">进程启动时间</h4><p><code>pgrep</code> 命令还实现了判断哪个进程最先创建和哪个进程最后创建，这部分功能通过读取 <code>/proc/self/stat</code> 实现。</p><p>以空格为分割，该文件的第 21 个元素即为该进程的 <strong>start_time</strong>（下标从 0 开始）。</p><p>但 <strong>start_time</strong> 并不唯一对应一个进程，因此在对 <strong>start_time</strong> 排序结束后需要对相同的 <strong>start_time</strong> 的进程的 pid 进行排序（存疑，但确实如此）。</p><h3 id="参考文献-3">参考文献</h3><ul><li><a href="https://docs.kernel.org/filesystems/proc.html#process-specific-subdirectories">Kernel Archive: proc</a></li><li><a href="https://unix.stackexchange.com/questions/7870/how-to-check-how-long-a-process-has-been-running">StackExchange</a></li><li><a href="https://man.netbsd.org/NetBSD-9.3/pgrep.1">NetBSD Manual</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;procps&lt;/code&gt; 是一套用于收集统计系统信息的套件，也指代一套访问 &lt;code&gt;/proc&lt;/code&gt; 文件系统的 API。uutils 的 procps 是用 Rust 重新实现的，而这正好是本次 GSoC 的提案内容。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JWT 小册</title>
    <link href="https://blog.krysztal.dev/2024/02/21/JWT-%E5%B0%8F%E5%86%8C/"/>
    <id>https://blog.krysztal.dev/2024/02/21/JWT-%E5%B0%8F%E5%86%8C/</id>
    <published>2024-02-21T20:52:14.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>JWT（JSON Web Token） 是一种分布式、跨域的单点登录方式，他开销很小而且天然支持分布式。</p><span id="more"></span><p>十分实用呐！<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[看看 jwt.io](https://jwt.io/)">[0]</span></a></sup></p><h2 id="结构">结构</h2><p>JWT 以 <code>.</code> 作为分割，储存以下内容</p><ul><li>Header：标识 JWT 的基本信息，比如算法等</li><li>Payload：负载，在这里会承载 JWT 的基础要素</li><li>Signature：签名，当 JWT 被恶意修改时将会无法验证，此时判定 JWT 失效</li></ul><p>举个例子，典型的 JWT 应该是长成下面这样子</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c<br></code></pre></td></tr></table></figure><h3 id="header">Header</h3><p>这里的字段是相对固定的：算法和 Token 类型</p><p>举个例子，使用 <code>HS256</code> 的算法的 JWT 的 Header 应该是如下样式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="payload">Payload</h3><p>常见的 Payload 字段有 7 个，所有的字段名都尽可能缩减为 3 个字母</p><p>如下表格即是 7 个标准 Payload 字段的定义以及是否可选</p><table><thead><tr class="header"><th style="text-align: center;">字段名</th><th style="text-align: center;">备注</th><th style="text-align: center;">是否可选</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">exp</td><td style="text-align: center;">过期时间</td><td style="text-align: center;">❎</td></tr><tr class="even"><td style="text-align: center;">iss</td><td style="text-align: center;">发布者</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">sub</td><td style="text-align: center;">主题</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">aud</td><td style="text-align: center;">接收者</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">nbf</td><td style="text-align: center;">在此之前不生效</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">iat</td><td style="text-align: center;">发布时间</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">jti</td><td style="text-align: center;">JWT 的 ID</td><td style="text-align: center;">✅</td></tr></tbody></table><p>除此之外还有很多其他的常用字段<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Wikipedia JWT](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields)">[1]</span></a></sup>。</p><h3 id="signature">Signature</h3><p>对于一串 Payload，我们使用密钥计算出他的签名，若是 Payload 被篡改那么签名也会不一致</p><p>如果签名不一致，那么就可以认为 Token 被篡改了</p><h2 id="签名算法">签名算法</h2><p>一般情况下使用 <code>HMAC</code> 足矣，但是有些为了特别安全的情况可以使用 <code>RSA</code> 或者 <code>ECDSA</code></p><h2 id="传输与储存方式">传输与储存方式</h2><p>JWT 可以储存在 HTTP 请求的 Header 里，这是最方便的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Authorization: Bearer &lt;token&gt;<br></code></pre></td></tr></table></figure><p>当然，HTTP 是明文传输这是十分不安全的，所以应该是有加密层的传输最好。</p><p>除此之外，也可以填入在请求体的某个字段里，不过这不是推荐的方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;jwt&quot;</span><span class="hljs-punctuation">:</span> &lt;token&gt;<span class="hljs-punctuation">,</span><br>    ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><!-- reference --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://jwt.io/">看看 jwt.io</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields">Wikipedia JWT</a><a href="#fnref:1" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;JWT（JSON Web Token） 是一种分布式、跨域的单点登录方式，他开销很小而且天然支持分布式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用密钥登录 SSH</title>
    <link href="https://blog.krysztal.dev/2024/01/31/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%20SSH/"/>
    <id>https://blog.krysztal.dev/2024/01/31/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%20SSH/</id>
    <published>2024-01-31T00:52:00.000Z</published>
    <updated>2024-09-22T11:36:37.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用密钥登录远程服务器应该是最安全方便的操作，没有密钥对的私匙谁都不能上你的服务器。就算是暴力破解也不行。</p><span id="more"></span><p>但是，一定要记住，root 的密码无论如何也要是强密码。</p><h2 id="准备过程">准备过程</h2><p>首先确认你的计算机里有没有 SSH Key，如果有的话直接用就好，不需要再次生成(假设用 ED25519 算法，如果是 RSA 算法把 <code>ed25519</code> 改成 <code>rsa</code> 就好)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><p>如果是空的话就需要做下一步，如果不是的话就执行如下命令并且跳过下一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xclip -sel clip &lt; ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><p>这条命令的意思是把输出的东西传送到剪贴板里，Linux 很神奇罢！</p><h2 id="生成密钥对">生成密钥对</h2><p>TODO</p><h2 id="配置远程服务器允许使用密钥登录">配置远程服务器允许使用密钥登录</h2><p>登录到远程服务器，并且打开 <code>/etc/ssh/sshd_config</code> 文件，把如下内容的注释去掉</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">...<br>PubkeyAuthentication yes<br>...<br></code></pre></td></tr></table></figure><p>然后打开 <code>.ssh/authorized_keys</code> 这个文件，把剪切板里的东西复制进去，大功告成</p><h2 id="后记">后记</h2><ul><li><code>.ssh/</code> 的权限必须是 <code>700</code></li><li><code>.ssh/authorized_keys</code> 的权限必须是 <code>600</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用密钥登录远程服务器应该是最安全方便的操作，没有密钥对的私匙谁都不能上你的服务器。就算是暴力破解也不行。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Guava：Cache</title>
    <link href="https://blog.krysztal.dev/2023/10/18/Guava%EF%BC%9ACache/"/>
    <id>https://blog.krysztal.dev/2023/10/18/Guava%EF%BC%9ACache/</id>
    <published>2023-10-18T19:18:39.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在开车的时候，与前方车辆一定要保持适当的距离，不管车速如何都是如此。这段距离叫做缓冲距离；在开发中也有类似的概念，不过分为 <code>Buffer</code> 和 <code>Cache</code>，<code>Cache</code> 偏向无序，<code>Buffer</code> 偏向有序。</p><span id="more"></span><h2 id="为什么要用-cache用-hashmap-不是更好">为什么要用 <code>Cache</code>？用 HashMap 不是更好？</h2><p>听着，我知道你很喜欢用 HashMap 也很喜欢自己造轮子。但是你要知道，你自己造的轮子大概率功能比不过 Guava 这种久经风霜的库，即使 Guava 非常的重并且非常的庞大。</p><p>为什么用 <code>Guava</code> 的 Cache？单纯就是方便。Guava 的 <code>Cache</code> 提供了以下非常吸引人的方面特性。</p><ul><li>从命令行式参数构建</li><li>过期时行为</li><li>多种驱逐方式</li></ul><p>即使 Guava 的 <code>Cache</code> 实现非常的简单，我们也没有必要去和 Guava 这种经历了长期考验的库看谁做的好。节约时间很重要。</p><h2 id="构建你的-cache-视图">构建你的 <code>Cache</code> 视图</h2><p>对于是否可以安全的在多个线程之间共享一个 <code>Cache</code>，答案是可以：<code>Cache</code> 最核心的实现其实是 <code>ConcurrentHashMap</code>，因此是线程安全的。</p><h3 id="选择驱逐模式-eviction">选择驱逐模式 (Eviction)</h3><p>Guava 的 <code>Cache</code> 提供了三种驱逐模式，适用于不同的场合。当然到底该用什么驱逐模式应该由开发者自己决定。</p><ul><li>基于时间的驱逐模式 <a href="https://github.com/google/guava/wiki/CachesExplained#timed-eviction">Timed Eviction</a></li><li>基于大小的驱逐模式 <a href="https://github.com/google/guava/wiki/CachesExplained#size-based-eviction">Size-based Eviction</a></li><li>基于引用的驱逐模式 <a href="https://github.com/google/guava/wiki/CachesExplained#reference-based-eviction">Reference-based Eviction</a></li></ul><p>请查阅给出的链接选择适合你的模式。对于一般项目来讲，最合适的是基于时间的驱逐模式以及基于大小的驱逐模式，基于引用的驱逐模式很少用，这种需要借助 GC 进行缓存驱逐的驱逐策略难判断什么时候会缓存穿透。</p><h3 id="缓存权重">缓存权重</h3><p>TODO</p><h3 id="驱逐时的监听器">驱逐时的监听器</h3><p>假设一个情景，你的缓存是一种面向反复查询数据库的缓存，你的缓存能暂时保存数据，并且在过期时写入缓存内的数据到数据库里。</p><p>这个时候，你就需要设计驱逐时的监听器了——驱逐时把缓存里的东西写到数据库里。</p><h2 id="其他建议">其他建议</h2><p>考虑到缓存有可能是需要异步的，但是 Guava 没有提供这种操作。所以 Guava 建议使用 <a href="https://github.com/ben-manes/caffeine">Caffeine</a> 这个项目。</p><p>不用担心，Guava <code>Cache</code> 和 <code>Caffeine</code> 项目的使用方法几乎一模一样。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开车的时候，与前方车辆一定要保持适当的距离，不管车速如何都是如此。这段距离叫做缓冲距离；在开发中也有类似的概念，不过分为 &lt;code&gt;Buffer&lt;/code&gt; 和 &lt;code&gt;Cache&lt;/code&gt;，&lt;code&gt;Cache&lt;/code&gt; 偏向无序，&lt;code&gt;Buffer&lt;/code&gt; 偏向有序。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编译器笔记：增量编译</title>
    <link href="https://blog.krysztal.dev/2023/10/06/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/"/>
    <id>https://blog.krysztal.dev/2023/10/06/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</id>
    <published>2023-10-06T00:33:44.000Z</published>
    <updated>2024-09-22T11:36:37.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如何让编译程序尽可能的快？并行化编译是最原始的做法——让每个单元都互相独立编译，并且尽可能多地同时编译。更进阶的做法就是——增量编译。</p><span id="more"></span><h2 id="增量编译原理">增量编译原理</h2><p>增量编译的基础可以是并行化编译，也可以是串行编译。但是这只是过程，最重要的是能对每个文件进行单元化编译。</p><p>这是并行化编译的基础，从速度上考虑增量编译的单元应该是文件而不是文本内容，如果一个文件内容变化了一点但是需要大量的 <code>differ</code> 计算那我们不如直接从 0 开始编译。</p><h2 id="如何实现一个简单的增量编译">如何实现一个简单的增量编译</h2><p>我会用最简单的话来讲述实现增量编译的原理，甚至简单到不需要有太多编译相关的知识。</p><p>我们假定在 <code>.caches</code> 文件夹下有一个 <code>compile.json</code> 文件，用于记录上一次编译所产生的文件的信息：包含最小编译单元的 Digest（比如 MD5，SHA256），该单元输出的 Digest。</p><p>在编译文件时，先检查 <code>compile.json</code> 文件里是否有对应的信息：</p><ul><li>如果有的话<ul><li>检查编译单元的 Digest 是否发生变动（ Differ ）<ul><li>已经变动：重新编译并且记录最小编译单元的 Digest，记录该单元的编译输出的 Digest</li><li>没有变动：查找该单元是否已经编译过<ul><li>已经编译过并且编译输出的 Digest 和记录值相同则不作编译</li><li>没有编译输出或者编译输出的 Digest 发生变动则重新编译</li></ul></li></ul></li></ul></li><li>如果没有的话<ul><li>编译该编译单元，并且记录该编译单元的 Digest 和该编译单元的编译输出的 Digest</li></ul></li></ul><p>这样就是一个很简单的增量编译处理方式——输入没变就去找输出，输出变了就重新输出；输入变了那输出肯定和之前就不一样了。</p><p>这种处理方式有一个问题，那就是对于大项目来讲如果经历大重构会出现一大堆没办法被处理掉的之前的编译输出：因为这些编译输出已经是以前的文件的了，编译单元被重构后路径也发生了变化。</p><p>所以会有些文件不会被处理掉。</p><p>但我觉得问题不大，因为 <code>cleanBuild</code> 也是很必要的——而且各位的开发机也不缺这点储存。</p><p>用一个更直观的图来表达这个过程吧！</p><figure><img src="drawio.png" alt="" /><figcaption>流程图</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何让编译程序尽可能的快？并行化编译是最原始的做法——让每个单元都互相独立编译，并且尽可能多地同时编译。更进阶的做法就是——增量编译。&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Gradle秘境：添加一个类似modCompileOnly的依赖块</title>
    <link href="https://blog.krysztal.dev/2023/09/17/Gradle%E7%A7%98%E5%A2%83%EF%BC%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCmodCompileOnly%E7%9A%84%E4%BE%9D%E8%B5%96%E5%9D%97/"/>
    <id>https://blog.krysztal.dev/2023/09/17/Gradle%E7%A7%98%E5%A2%83%EF%BC%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCmodCompileOnly%E7%9A%84%E4%BE%9D%E8%B5%96%E5%9D%97/</id>
    <published>2023-09-17T15:55:58.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>FabricLoom 里有类似 <code>modCompileOnly</code>、<code>modApi</code>、<code>modImplementation</code>、<code>modRuntimeOnly</code> 配置块，那应该怎么做才能在自己的 Gradle 插件里实现类似的功能？</p><span id="more"></span><p>假设：你已经会了 Kotlin，并且大概知道怎么使用 Gradle，并且 Gradle 的插件项目已经成功创建，并且可以成功被加载</p><h2 id="为什么要这么做那是什么">为什么要这么做？那是什么？</h2><p>先介绍一下 FabricLoom 这个 Gradle 插件的的 <code>modCompileOnly</code> 等配置块的功能。</p><p>这个配置块用于在 <code>dependencies</code> 块里描述一个新的依赖，但是 Gradle 会依赖你写的是 <code>implementation</code> 或者 <code>compileOnly</code> 而执行对应的功能。</p><p>举个例子，你会在 FabricLoom 项目的 build.gradle 里面看到类似这样的配置块：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    minecraft <span class="hljs-string">&quot;com.mojang:minecraft:$&#123;project.minecraft_version&#125;&quot;</span><br>    mappings <span class="hljs-string">&quot;net.fabricmc<span class="emoji" alias="yarn" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f9f6.png?v8">&#x1f9f6;</span>$&#123;project.yarn_mappings&#125;:v2&quot;</span><br>    modImplementation <span class="hljs-string">&quot;net.fabricmc:fabric-loader:$&#123;project.loader_version&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是你会发现，往往不需要再次声明一次对于 <code>net.fabricmc:fabric-loader:$&#123;project.loader_version&#125;</code> 这个依赖的 <code>implementation</code> 配置块。</p><p>这是为什么？因为 <code>modImplementation</code> 配置块继承了 <code>implementation</code> 配置块，所以在这项依赖被 <code>implementation</code> 配置块对应的处理器处理后，可以被 FabricLoom 再次收集信息，加入 Minecraft Client 的模组加载列表里面！</p><p>很好，这下应该解释清楚了为什么要做这项工作，那么我们的正事开始——设计新的 <code>plImplementation</code> 配置块，并且收集所有配置块的信息。</p><h2 id="代码实现">代码实现</h2><p>接下来的代码用 Kotlin 实现，所以前文需要假设你会 Kotlin（毕竟 Kotlin 不难）</p><p>先想清楚我们要做什么：添加一个叫做 <code>plImplementation</code> 的依赖块，可以写到 <code>dependencies</code> 块里，并且它可以被视为是正常的 <code>implementation</code> 块能被当作依赖处理。</p><h3 id="新增一个-configuration">新增一个 <code>configuration</code></h3><p>在 Gradle 插件进行注册的时候，我们把这段代码写到插件注册里去</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">configuration.register(<span class="hljs-string">&quot;plImplementation&quot;</span>) &#123;<br>    it.extendsFrom(configuration.getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME))<br>    it.description = <span class="hljs-string">&quot;Extend from `implementation`, but it will add dependencies into `plugins` directory.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要成功运行那就是注册成功，这里通过 <code>it$extendsFrom</code> 说明了它是继承了 <code>implementation</code> 块。</p><h3 id="taskaction-里进行操作"><code>@TaskAction</code> 里进行操作</h3><p>在 <code>@TaskAction</code> 里我们这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">project.configurations<br>    .getByName(<span class="hljs-string">&quot;plImplementation&quot;</span>)<br>    .incoming<br>    .resolutionResult<br>    .allComponents<br>    .forEach &#123; result -&gt;<br>        result.dependencies.forEach &#123; dependency -&gt;<br>            project.logger.info(<span class="hljs-string">&quot;:<span class="hljs-variable">$PL_TASK_EVALUATE_PLUGIN</span>: <span class="hljs-variable">$dependency</span>&quot;</span>)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样就可以获取到如下 <code>plImplementation</code> 块的依赖了，并且对他进行额外处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencies &#123;<br>    plImplementation(<span class="hljs-string">&quot;net.fabricmc:fabric-loader:<span class="hljs-subst">$&#123;project.loader_version&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;FabricLoom 里有类似 &lt;code&gt;modCompileOnly&lt;/code&gt;、&lt;code&gt;modApi&lt;/code&gt;、&lt;code&gt;modImplementation&lt;/code&gt;、&lt;code&gt;modRuntimeOnly&lt;/code&gt; 配置块，那应该怎么做才能在自己的 Gradle 插件里实现类似的功能？&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Minecraft：原始经济系统设计简述</title>
    <link href="https://blog.krysztal.dev/2023/08/26/Minecraft%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/"/>
    <id>https://blog.krysztal.dev/2023/08/26/Minecraft%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/</id>
    <published>2023-08-26T16:49:36.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如何在 Minecraft 设计经济系统是一个服务器维护人员以及策划组持久讨论的问题，那么过了这么多年我能给出什么方案？</p><span id="more"></span><h2 id="经济系统基础">经济系统基础</h2><p>首先需要了解经济系统的一般特性，在了解经济系统的一般特性后我们可以以此为理论基础进一步设计原始的经济系统<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MBA 智库：经济系统](https://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F)">[0]</span></a></sup></p><blockquote><p>(1)经济系统的整体性。经济系统是由相互联系和相互作用的若干经济元素结合而成的有机整体。各个经济元素与经济系统之间的关系是整体和部分的关系。各经济元素在功能上必须与经济系统整体适应，居于经济系统整体的从属地位。正是由于系统局部的统一性，才构成了系统的整体性。所以，我们在处理任何经济系统问题时，应坚持从经济系统的整体出发，从全局出发，发挥经济系统整体的特定功能和效益。</p><p>(2)经济系统的层次性。局部的独立性构成系统的层次性。经济系统的层次，指经济系统中各经济元素之间的地位、等级关系。它反映了经济系统是可以组合的，也是可以分解的。经济系统的各个组成部分既可以自成系统，又可以互为系统。不同层次或同一层次的经济元素既有共同的运行规律，又有各自的运行规律。经济系统的层次及其层次之间的关系说明经济系统具有多层次性。</p><p>(3)经济系统的结构性。经济系统的结构，指经济系统内部各个经济元素之间的相互联系和相互作用的结合形式。它反映了经济系统中各经济元素之间的比例关系、排列顺序和结合方式。合理的经济结构，能使经济系统具有生命力，更加协调地运行。一般来讲，经济系统结构具有相对的稳定性。对不合理的经济系统结构要进行调整，保持经济系统的合理运行。总之，经济系统的结构是否合理，关系到社会经济发展的战略问题，关系到经济系统特定功能与效益的发挥和提高问题。</p><p>(4)经济系统的开放性。开放性是针对封闭性而言的。开放系统是与其他系统进行物质、能量、信息交换的系统。自然界中存在的一切系统，几乎都是开放系统。完全与外界隔绝的孤立系统实际上并不存在。经济系统的开放性，指经济系统与物质、能量、信息等的相互关系。如果一个经济系统开放性很强，说明它与环境交换的物质、能量、信息的数量大，范围广泛，种类繁多。开放的经济系统既受到国内自然条件、生态环境、资源数量等自然环境的制约，又受到人口状况、经济体制和政策等社会经济环境的影响。所以，够开放的中国保持经济系统的开放性，非常必要。</p></blockquote><p>有了最原始的理论基础，接下来我们来细细分析这些理论基础能导出什么。</p><h3 id="经济系统的整体性">经济系统的整体性</h3><h4 id="什么叫做有机的整体">什么叫做有机的整体？</h4><blockquote><p>经济系统是由相互联系和相互作用的若干经济元素结合而成的有机整体</p></blockquote><p>经济系统是一个巨系统，一个系统是由多个不同的部分组成，而巨系统是由多个不同的系统组成。</p><p>什么是经济元素？元素就是构成新个体的基础要素，这里的定义为：信息、物质、能量、时间、空间<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这部分是微观经济元素，定义并不是很明确，只能暂时这么定义，并且这么定义是符合上下文的关系的。">[1]</span></a></sup>或个人、企业、政府、市场、资源<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这里是宏观的经济元素，定义较为明确，但不唯一。">[2]</span></a></sup>。</p><p>它们之间互相协调互相影响，最终到达一个稳定的点，成为一个有机系统。</p><p>比如：当一个物件使用原始的工艺需要<em>大量的时间</em>与<em>大量物质</em>去生产，改良后的工艺在生产该物件时可以<em>大幅度缩减该物件的时间要素与物质要素</em>，但我们需要投入更多的物质与时间到<em>改进工艺</em>这个步骤，因此在这一个生产流程之中产生了一个平衡：投入时间与物质到改进工艺，但生产物件所需要的时间与物质减少。</p><p>由于例子内的元素需求达到了一种有机平衡，从整条生产过程来看最终的结果是导致该物件的成本会被稀释，该物件若需求不变的情况下经济价值会变低。正是因为各个局部经济元素之间有一定程度的统一性和协调性，才会使得经济系统体现出一定的整体性。</p><blockquote><p>我们在处理任何经济系统问题时，应坚持从经济系统的整体出发，从全局出发，发挥经济系统整体的特定功能和效益</p></blockquote><p>这句话定义了一个分析任何经济系统问题的方法论，我们应该始终从整体角度出发，考虑全局因素，才能确保经济系统的稳定发展。</p><h4 id="举个例子">举个例子</h4><p>举个比较现实的例子，这种方法论也适合分析任何巨系统面临的问题。</p><blockquote><p>想象一个城市的交通系统作为一个例子。</p><p>在城市交通系统中，各种交通方式（汽车、公共交通、自行车等）构成了交通系统的各个经济元素。每种交通方式都有其特定的功能和效益，但它们需要与整个交通系统相适应，以确保城市内的流动性和效率。</p><p>各个交通方式之间的关系体现了整体和部分之间的关系。例如，交通信号灯、道路规划、公交车站等都是整个交通系统的一部分，它们的协调和协作对于整个系统的正常运行至关重要。</p><p>每种交通方式在功能上需要与整个交通系统整体适应。例如，公共交通系统需要根据人口分布和需求来安排线路，以满足市民的出行需求。同时，道路规划也需要考虑各种交通方式的流量，以保证交通的顺畅。</p><p>整个交通系统的整体性在于，各种交通方式共同构成了一个互相依赖的有机结构，城市的交通运行取决于这些交通方式的协调和平衡。如果某种交通方式出现问题，可能会影响整个系统的效率，导致交通拥堵等问题。</p></blockquote><p>从整体的方向（交通系统）分析了设计交通红绿灯、公交等局部系统的设计，最终达到解决问题的目标。</p><p>但是与此同时，一个系统瘫痪会影响到整体巨系统的效率，表现为交通拥堵。</p><h3 id="经济系统的层次性">经济系统的层次性</h3><h4 id="理解层次性">理解层次性</h4><p>这非常容易理解，最典型的为供应链，一种常见但是算比较复杂的经济系统。</p><p>接下来我把一个供应链的简化结构按照层次从第一层次到最终层次列举出来。</p><ul><li>原材料供应商：整个系统的基础，<strong>影响着上下游的产物基础价格</strong>。</li><li>制造商：它们会把原料组装成为最终的成品，它们的工艺以及运营和决策<strong>决定了了产品的质量和整条供应链的可靠性</strong>。</li><li>分销商与批发商：库存端，它们可以决定产品的管理和所有订单的的履行，<strong>决定了供应链的灵活性以及效率</strong>。</li><li>零售商：将产品推向市场，使其成为商品。从消费者收集信息（例如需求）反馈给上游，<strong>决定了整个供应链的规划</strong>。</li><li>消费者：最终消费端，是整个供应链的动力来源，<strong>供应链到底生产什么以及生产多少</strong>和他们的需求有关。</li></ul><h4 id="什么叫做每个层次也可以独立">什么叫做每个层次也可以独立？</h4><p>我们把"原料供应商"这一层次单独取出来解释，为什么<em>各个组成部分既可以自成系统，又可以互为系统</em>。</p><p>原料供应商中依然存在供应链关系：原料供应商从原料生产者获取原料，最终加工成为初级材料。</p><p>典型的例子为乳业，在奶产品供应链中有奶农，奶厂，消费者。</p><p>原材料供应商由奶农和收购方构成，那么问题来了，他们能不能构成独立的系统？答案是可以！</p><p>奶农自己生产牛奶，自己喝掉，<strong>自己既是原材料供应商，也是消费者</strong>。 也可以自己生产牛奶，送给朋友喝，<strong>自己是原材料供应商，朋友是消费者</strong>。</p><p>这只是个"原材料供应商"角度的例子，甚至消费端也是成立的：你把你买到的物品送给朋友，<strong>只要有输入</strong>就能让系统运行下去。</p><h3 id="经济系统的结构性">经济系统的结构性</h3><p>像是现实生活中的结构一样，结构是有稳定性，更是具有组成部分的。</p><h4 id="为什么经济系统需要一定的结构性">为什么经济系统需要一定的结构性？</h4><p>经济系统需要一定的结构性，如果生产端一直生产没有消费这是可能的吗？这很明显是不可能的，生产端需要需求才能确定生产量，这样生产端迟早会因为产品无法被消费而损毁。</p><p>再比如，一个国家不可以只有制造业生产部门，这样的结构单一性过重，容易受到其他国家的冲击。而产业结构会影响经济结构：全是服务部门，会导致只能在服务端消费循环。</p><p>我将会以一个国家典型的经济结构解释。</p><h4 id="理解为什么一个国家经济结构不能过于单一">理解为什么一个国家经济结构不能过于单一</h4><p>一个国家往往包含以下结构</p><ul><li>家庭（家庭部门）： 家庭在经济结构中占据重要地位，因为它们提供劳动力、消费品的需求以及储蓄。家庭部门通过劳动力市场提供劳动力，通过商品市场提供需求，同时也可能从金融市场获取收入。</li><li>企业（企业部门）： 企业在经济结构中是生产者，它们生产商品和提供服务。企业通过商品市场向家庭和其他企业销售产品，通过劳动力市场雇佣劳动力，通过金融市场筹集资金。</li><li>政府（政府部门）： 政府在经济结构中扮演多重角色，包括提供公共服务、征税、开支以及监管。政府通过金融市场筹集资金，通过政策影响其他部门的活动。</li><li>金融市场： 金融市场是各个部门进行资金交流的场所。家庭、企业和政府都可以在金融市场融资或投资，从而影响整体的经济活动。</li><li>商品市场： 商品市场是各个部门交换物品和服务的地方。家庭购买消费品，企业之间交换原材料和产品，这些交换构成了商品市场的一部分。</li></ul><p>如果一个国家彻底抹除了商品市场，那么这部分的结构往往需要由政府来承担，一个角色承担了过多的职能会导致不稳定：因为受到自身的影响过多，<strong>一旦政府停摆对应的商品市场也会停摆</strong>，造成消费品与商品无法交流，企业之间也无法交换原材料完成生产职能，典型的例子是前苏联与朝鲜。</p><p>如果一个国家抹除了企业，那么将会由市场（金融与商品）承担这部分职能：<strong>消费品将会完全依赖进口</strong>，本国（本经济体）不再具有生产能力，典型的例子是马达加斯加。</p><h3 id="经济系统的开放性">经济系统的开放性</h3><p>一个经济系统，只有生产没有其他经济系统的输入，现实吗？</p><p>一个经济系统，只有生产没有向其他经济系统输出，现实吗？</p><p>其实可以，叫做小农经济。</p><p>这种经济在没有外来干扰的情况下非常稳定，但是发展极其缓慢：因为无法提高生产力。</p><p>如果一个经济体有原材料输入，那么这个经济体可以提高生产力而不降低本国原材料端获取效率，生产出的产品（消费品）可以供国内消费，同时过多的可以输出到国外与其他经济体交换。</p><p>这就是为什么开放的经济系统更加具有生命力：<strong>它们更符合互通有无的特性</strong>。</p><h2 id="剖析-minecraft">剖析 Minecraft</h2><p>有了基础理论，我们可以开始剖析 Minecraft 和考虑实行的可行性了。</p><p>以下的考虑均基于 Vanilla Minecraft，而不是任何的 Modded Minecraft。</p><h3 id="vanilla-minecraft-里有什么玩家扮演了什么">Vanilla Minecraft 里有什么？玩家扮演了什么？</h3><p>玩家在游戏内可以承担多种角色：生产者，消费者，甚至是零售商。</p><p>每个玩家都可以是一个独立的系统：他们可以不去购买资源，完完全全自己获取资源。</p><p>最原始的资源为服务器地图中所能产生的资源：所有方块，所有奖励箱内的东西，所有玩家能获取到的物资。</p><p>玩家在初期则全部为资源获取者，他们都需要获取最原始的资源。</p><p>中期玩家是资源消费端，玩家需要不断的消耗资源，或者转换资源成为其他更少获得的资源。</p><p>在末期玩家会不断的出售自己的资源，将自己的资源出售转换成为虚拟货币，以备不时之需。</p><p>我们需要重新规划玩家的游戏历程，甚至破坏 Vanilla Minecraft 的游戏历程，让玩家不能快速地到达末期。</p><h3 id="分析游戏历程以及分析玩家的扮演阶段">分析游戏历程，以及分析玩家的扮演阶段</h3><p>在 Vanilla Minecraft，一个典型的流程为</p><pre><code class=" mermaid">graph LR主世界.-&gt;红石玩家开始研究红石机器主世界 --获取资源--&gt; 地狱 --获取资源以及强化装备--&gt; 末地 --获取翅鞘等--&gt;主世界地狱 --获取下界之星--&gt; 搭建信标搭建信标--&gt;毕业末地--获取龙蛋--&gt;毕业</code></pre><p>也就是说当玩家成功搭建完毕信标，或者获取到龙蛋，这个游戏的历程就结束了，玩家选择不再上线等等。</p><p>除此之外，玩家玩到无聊了就自然不上线了，这也是一种特例，因为是服务器本身的活力不足导致的问题，这种情况下应该鼓励玩家邀请朋友一起游玩，以及适当的福利以及适当的活动。（除了每日上线以及一些日常活动）</p><p>当然，红石玩家是特例，红石玩家不会有毕业的时候，并且是最大的资源生产大头以及消费大头。这部分玩家我们暂时不讨论，因为情况特殊。但是我们需要考虑一些特别的机制：刷怪塔等让某种资源获取效率发生极大变化的结构以及机制。</p><h3 id="结论">结论</h3><p>我们现在清楚了，服务器的资源情况取决于玩家当前进入了什么阶段，玩家进入了什么阶段也会影响该玩家在服务器的活跃程度。</p><p>还要考虑玩家之间交换物品的方式，因为原始的以物易物也是经济的一部分。</p><p>我们需要考虑的地方：</p><ul><li>玩家的游戏历程以及阶段</li><li>物品应该如何在玩家之间流通</li><li>物品的价值如何界定</li><li>稳定货币应该是什么</li><li>货币系统如何运作</li></ul><h2 id="货币系统基础">货币系统基础</h2><p>由于 Vanilla Minecraft 的经济系统为闭环系统，在不存在“无限收购”的前提下，玩家持有的货币始终等于“信用体系”总的货币，也就是所有玩家的资产加起来等于服务器总的资产，服务器需要负责承担“发行者”的角色——服务器货币的总量，取决于服务器愿意发行多少货币给玩家。</p><h3 id="通货膨胀通货紧缩">通货膨胀？通货紧缩？</h3><p>这是两个很重要的经济学现象，由于表达货币和需求之间的关系。</p><p>通货膨胀具体表现为货币贬值，但是货币贬值与通货膨胀实际为两种领域的现象，只是它们之间有相互的关联性。</p><p>用人话来讲，就是物价上升，人们的购买力减少。而通货紧缩则相反，物价下跌人们的购买力提升。</p><p>那么为什么会产生这两种现象？</p><p>当流入市场的货币总量变多，货物的供给没有变或者降低时则会造成通货膨胀。</p><p>当流入货币的市场的总量变少，货物的供给没有变或者便多则会造成通货紧缩。</p><p>这是两种完全无法避免的经济现象，但是在经济学上一般认为微量的通货膨胀是可以容忍的——因为这可以让一些价格，比如薪资和一些难以改变的物价可以重新定价。而通货紧缩则没有类似的功能，持续的通货紧缩将会造成生产端的破产以及经济衰退。</p><p>因此我们暂时认为，我们在设计整个经济系统需要保持整个经济系统呈现出微量通货膨胀的状态。</p><h3 id="基础货币">基础货币</h3><p>基础货币(<span class="math inline">\(Base\ Currency\)</span>，后文称之为 <span class="math inline">\(B\)</span> 货币)也称之为高能货币，这种货币投入到市场可以成倍扩增货币——举个例子，假如 <span class="math inline">\(A\)</span> 货币与基础货币的价值比值为 100:1，那么向市场内投入 1 基础货币相当于增加了 100 枚 <span class="math inline">\(A\)</span> 货币。</p><p>这种货币一般不直接使用，而是替换为流通货币(<span class="math inline">\(Currency\ In\ Circulation\)</span>)。</p><p>我们现在已经明白了基础货币 <span class="math inline">\(B\)</span> 和流通货币 <span class="math inline">\(A\)</span> 的关系实际上等于 <span class="math inline">\(A = nB\)</span> , <span class="math inline">\(n\)</span> 为货币倍率。</p><p>那么基础货币总量怎么计算？基础货币总量可以用一个非常简单但是可以变得非常复杂的式子来表示。</p><p><span class="math display">\[中央银行资产A1 + 中央银行负债A2 \approx 基础货币总量\]</span></p><p>由此我们可以大致估算基础货币到底有多少。对于一个简单的经济系统而言，我们就单纯认为服务器内基础货币总量计算方法为如下</p><p><span class="math display">\[玩家总资产A1 \approx 基础货币总量\]</span></p><h3 id="流通货币">流通货币</h3><p>流通货币( <span class="math inline">\(Currency\ In\ Circulation\)</span> )为最终投放到市场里的货币，与基础货币之间存有一定的比值。</p><p>我们可以用下面这样的示意图来表达基础货币和流通货币的关系</p><pre><code class=" mermaid">graph基础货币-- x1 --&gt;美元基础货币-- x8 --&gt;人民币基础货币-- x146 --&gt;日元</code></pre><p>考虑到 Vanilla Minecraft 的系统，就算是使用 Plug-in Vanilla Minecraft (eg. Spigot) 也大多数使用一种流通货币，那么我们现在就简单的认为流通货币和基础货币比例为 1:1</p><h3 id="微量的通货膨胀">微量的通货膨胀</h3><p>我们前面提到了，我们先假设每天的市场需求是不变的，那我们可以控制投放到市场中的货币，投放到市场中的货币多了我们的通货膨胀目标就实现了。</p><p>当然，前提是我们需要假设每天的市场需求是固定的，增加玩家的购买力，那玩家就有更多的钱去购买物品，供应商自然会给物品涨价，实现微量的通货膨胀。</p><p>那我们怎么实现投放到市场中的货币？答案是：每天上线就给玩家发钱。</p><p>非常简单粗暴的方法，那还有没有其他的？有，银行利率就是宏观调控通货膨胀的一部分。</p><p>但是这种方法需要额外设计银行系统，太复杂了我们就不探讨了吧 XD（目移</p><p>我们就简单的认为每天给玩家发钱就是控制通货膨胀的一部分就好了。</p><h3 id="税收">税收</h3><p>税收也是经济活动中重要的组成部分，税收可以有效抑制<em>需求拉动型的通货膨胀</em><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MBA 智库: 需求拉升型通货膨胀](https://wiki.mbalib.com/wiki/%E9%9C%80%E6%B1%82%E6%8B%89%E5%8A%A8%E5%9E%8B%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80)">[3]</span></a></sup>。</p><p>我们在这里探讨一下所得税，让后文的逻辑更加通顺，提供一种抑制通货膨胀的思路。</p><h4 id="需求拉动型的通货膨胀">需求拉动型的通货膨胀</h4><p>先解释一下什么叫做<em>需求拉动型的通货膨胀</em>。</p><p>假设全部的玩家都在开荒初期，那么势必会产生一种情况：物品全部价格起飞，因为这个时候需求极大，售卖方可以狠狠地捞一笔，最终导致了需求拉动型的通货膨胀。</p><p>然后？然后因为太贵了，没人买，需求回落，价格骤降，变成没人卖，玩家有钱花不出去，产生通货紧缩。</p><p>这种一种很自然的经济周期，但是有些逆周期的经济行为，不过我们不探讨。</p><h4 id="如何应对">如何应对</h4><p>那就是宏观调控，有两种方案。</p><p>方案 1: 向市场中投放足够多的平价货物，满足购买方的实际需求</p><p>方案 2: 对购买方征收所得税，降低购买方的意愿，进而延缓通货膨胀的速度。</p><p>不过我们需要知道的是，第二种方案实际上并不会解决通货膨胀的问题，它可以让通货膨胀变得足够缓慢，形成菲利普斯曲线<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MBA 智库: 菲利普斯曲线](https://wiki.mbalib.com/wiki/%E8%8F%B2%E5%88%A9%E6%99%AE%E6%96%AF%E6%9B%B2%E7%BA%BF)">[4]</span></a></sup>。</p><p>在本节内容我们讨论第二种方案，现实生活中往往是两种方案混用。</p><p>我们在购买物品的时候会产生所得税，纳税人是购买方，当对于这种物品税收过重时我们对这种物品的需求就会降低，因为实际上太贵了，商家也没赚到多少钱。</p><p>那这样看，不是他会通货紧缩吗？说好的通货膨胀呢？因为往往我们不会设置太高的税收，我们的最终目的是防止这种物品导致过快的通货膨胀。</p><p>我想买的东西是必需品，即使是它税很重，我也会去购买。</p><p>商家在短时间内会意识到市场的需求上升，因为很多玩家都需要，所以会涨价（增加供给）。</p><p>但是买方因为税收不会多买，会以后再买（需求降低）。</p><p>在这时就产生了通货膨胀，但是与此同时玩家的需求是被压制的。</p><p>商家在买方需求降低后慢慢减少上架的货物（减少供给）。</p><p>在渡过高需求的阶段后可以适当降低税收，玩家的需求会上升（需求上升）。</p><p>由此完成了整个经济周期，并且结果税收的调控后通货膨胀显得比较平稳不至于货价高速膨胀。</p><p>但是这种通货膨胀是<strong>健康</strong>的，只要它经过<strong>调控</strong>。</p><p>从长远来看，市场是有自我调控能力的，即使是不设置税收他也能自己调节。</p><p>但是从长远看，到底多长远？所以我们<strong>基于市场需要一定的干预的前提</strong>认为税收是有必要的。</p><h2 id="动手设计">动手设计</h2><p>我们简单地探讨了一下一个经济系统需要什么东西，那么我们开始收集一个经济系统需要什么部分吧！</p><p>由以上的探讨我们可以以一个极其原始的观点开始构建一个比较简单的经济系统。</p><ul><li>基础货币 <span class="math inline">\(Base\ Currency\)</span></li><li>流通货币 <span class="math inline">\(Currency\ In\ Circulation\)</span></li><li>基础货币与流通货币的换算关系</li><li>基础货币的具体表现形式</li><li>玩家间货币的流转</li><li>官方市场，用于提供官方控制物价的市场</li><li>物品的定价规则</li><li>税收，以及税收后的去向</li><li>通货膨胀的形式</li></ul><h3 id="货币系统">货币系统</h3><p>作为一个货币系统，首先我们需要一个基础货币，我们叫他 <span class="math inline">\(B\)</span> 货币吧！</p><p><span class="math inline">\(B\)</span> 货币作为世界通用货币，但是不在任何经济体系中流通，因为它不是<strong>流通货币</strong>。</p><p>为了我们设计方便，我们就额外设计一个 <span class="math inline">\(A\)</span> 货币，其和 <span class="math inline">\(B\)</span> 货币兑换的比值为 <span class="math inline">\(1:1\)</span></p><p>我们需要一种物品来描述 <span class="math inline">\(B\)</span> 货币，那么挑选一个合适的物品吧！这种物品没有太多用途，玩家甚至不想要。那就...暂定成铜锭吧，我们让这种物品从世界上彻底消失，无法获取也不参与任何合成表。</p><p>它和 <span class="math inline">\(B\)</span> 货币比值为 <span class="math inline">\(1:100\)</span>，也就是 1 个铜锭实际上等于 100 个 <span class="math inline">\(B\)</span> 货币</p><p>用以下示意图表示</p><pre><code class=" mermaid">graph LR铜锭--- |x100| B货币B货币--- |x1| A货币B货币--- |x10| C货币B货币--- |x50| D货币</code></pre><h3 id="市场">市场</h3><p>涉及到市场，必定分为由管理员设立的市场以及玩家互相之间的市场，在这里我们只讨论管理员设立的市场，玩家之间设立的市场我们称之为"黑市"，管理员设立的市场称之为"白市"</p><p>白市需要确定哪些物品可以在此出售，因为市场需要一定的管控，并且需要设置最低的物价。</p><p>在最低的物价之上允许玩家自由定价，并且需要管理员对物价进行管理，防止玩家对物价进行恶意炒作，产生垄断现象。</p><p>对于黑市，也就是玩家之间的自由市场，白市应当与黑市正面竞争，在可以的情况下需要和黑市拼比同等物品的价格，并且白市应当尽可能的扩充自己可以出售的物品。</p><p>于是我们面对新的问题：物品定价</p><h4 id="物品定价">物品定价</h4><p>对于物品定价，需要遵守一定的规律：</p><ul><li>若是稀有物品：考虑从稀有程度下手，不可再生并且无功能的的稀有物品应当禁止出售，并且尽可能压低该物品的价值</li><li>若是资源物品：考虑从丰度下手，比如矿石等。再考虑获取的时间成本，这种物品应当鼓励玩家出售</li><li>若是功能物品：考虑从获取难易度下手，比如附魔书。该物品定价需要一定的技巧，需要考虑获取难度以及物品的功能性</li></ul><h4 id="物品定价资源物品">物品定价：资源物品</h4><p>我们以矿石为例，一个矿石产物的定价可以以以下的函数为计算方式</p><p><span class="math display">\[价格P0=基础价格P1+劳动成本B*\sqrt{矿石丰度A}*资源系数X \\\]</span></p><p><span class="math display">\[矿石丰度A=区块生成期望Y\]</span></p><p><span class="math display">\[劳动成本B=平均获取时间T\]</span></p><p>资源系数为社区需求程度，我们假设这是个固定值，实际上这个系数可以非常地动态。</p><p>考虑钻石的情况，我们令物品的基础售价为<span class="math inline">\(P1=100\)</span>，<span class="math inline">\(B=T=600s*1\)</span>，<span class="math inline">\(A=3\)</span>，<span class="math inline">\(X=100\)</span></p><p>那我们的式子就变成了这样：</p><p><span class="math display">\[P0=100+600*\sqrt{3}*100 \approx 100+600*1*100=60100\]</span></p><p>一个钻石的价格就是 <span class="math inline">\(P0=60100\)</span> 了。</p><p>当然，这个式子非常粗糙，一定要重新设计，一定要重新设计，一定要重新设计，重要的话要说三次。</p><h3 id="税收设计">税收设计</h3><p>对于服务器而言，不想要考虑税收收上来的税用于做什么——哪怕是退税都不需要考虑。</p><p>所以我们可以简单的认为税收就是为了有效抑制需求拉动型通货膨胀的手段，并且用于回收市场的金币。</p><p>税收是一种有效抑制需求拉动型通货膨胀的方案，但是这部分的操作是需要动态的——当需要通过税收抑制需求拉动型通货膨胀时，税收过低，导致税收没有起到抑制通货膨胀的作用；当不需要税收抑制需求拉动型通货膨胀时，过重的税收会导致通货紧缩，过大地抑制市场需求。</p><p>我们简单地认为价格为 <span class="math inline">\(ST\)</span> 的物品购买时产生的所得税税率为 <span class="math inline">\(TA\%\)</span>，那么玩家实际上需要使用 <span class="math inline">\(ST*(1+TA)\%\)</span> 流通货币来购买，那么税收则为 <span class="math inline">\(T=ST*TA\%\)</span>，本次交易中从市场里消失的货币为 <span class="math inline">\(T\)</span>。</p><p>当日从市场里消失的货币则为</p><p><span class="math display">\[D=\sum_{i=1}^{n}T_{i}，n=当日市场交易次数\]</span></p><p>但是，对于税收我们依然是需要去统计的——因为税收收上来的税不再有用途，但是会实实在在地减少市场中的金币，会导致通货紧缩，所以若需要保证经济系统微量通货膨胀，这部分减少的金币需要以另外一种方式还给玩家。</p><h3 id="通货膨胀">通货膨胀</h3><p>我们假设需要保证经济是微量通膨的，那么我们需要考虑到一个问题：不再活跃的玩家是否可以认为是市场流通货币的持有者？</p><p>因为如果一个玩家不再活跃了，相当于这个玩家以及这个玩家所持有的货币彻底从市场里消失了，这部分货币属于暂时蒸发状态，所以我们暂时认为这部分的玩家的货币已经不存在了，或者我们认为这部分玩家的货币自从某天突然从市场里<strong>消失</strong>了即可。</p><p>我们简单的认为我们地目的就是让市场里的钱以一定的比例变多，那么我们可以以以下的式子来进行计算。</p><p><span class="math display">\[I=\frac{当日投入到市场中的货币B-过去一天市场里减少的流通货币A}{活跃货币总量C}\]</span></p><p>其中 <span class="math inline">\(A\)</span> 包含了过去一天的总税收 <span class="math inline">\(T\)</span>，过去一天被判定为不活跃玩家的财产 <span class="math inline">\(F\)</span>，那么可以得到如下式子</p><p><span class="math display">\[A=过去一天的总税收T+过去一天被判定为不活跃玩家的财产F\]</span></p><p>那我们如何将 <span class="math inline">\(B\)</span> 投入到市场当中？答案是每日上线附送的金币。</p><p>考虑到存在玩家赎回财产，那么 <span class="math inline">\(A\)</span> 是有可能为负的，而我们要计算的 <span class="math inline">\(B\)</span> 会因此变成负数，反而从玩家包里扣钱，这显然是不可能的。</p><p>因此若 <span class="math inline">\(B\)</span> 小于 0 时，服务器不会发放当日的金币福利（或者仅仅保留基础福利）。</p><p>我们可以导出如下计算式子。</p><p><span class="math display">\[B=I*C+(T+F)\]</span></p><p>所以我们每日发给玩家的货币就变成了如下计算式。</p><p><span class="math display">\[PB=\frac{B}{n}，n=活跃玩家总数\]</span></p><p>总量为<span class="math inline">\(PB\)</span>的货币会在玩家上线时发给玩家。但我们不需要保证每天的任务都是达标的，如果我们需要保证每天的任务达标的话我们可以考虑直接加算到玩家的钱包里。</p><h2 id="收尾">收尾</h2><p>其实给 Vanilla Minecraft 设计经济系统总是一个不合适的想法，因为 Vanilla Minecraft 的资源实际上是无限的，几乎所有生产资料都是拿在玩家手上的，某种意义上是共产社会。</p><p>但是总是有很多玩家和维护人员乐此不疲地给他设计新的内容，即使是 Mojang 开始教玩家玩游戏，玩家也不会放弃实现他们的想法，或许这就是这个游戏即使是现在也依然生机勃勃的原因吧。</p><p>用一句很真实的话为我们的原始经济系统设计探讨之路画上句号吧。</p><blockquote><p>从长远来看，我们都死了。</p><footer><strong>John Maynard Keynes，约翰·梅纳德·凯恩斯</strong></footer></blockquote><p>不去做，怎么会知道他到底怎样？从长远来看，那又如何？</p><h2 id="叠甲">叠甲</h2><ul><li>笔者不是经济方面专业的学生，对于这部分的设计和想法是基于自己长期的经验积累以及阅读获取导出的。</li><li>如有不恰当的地方，还请斧正。</li></ul><!-- 引用 --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F">MBA 智库：经济系统</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这部分是微观经济元素，定义并不是很明确，只能暂时这么定义，并且这么定义是符合上下文的关系的。<a href="#fnref:1" rev="footnote"> ↩︎</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这里是宏观的经济元素，定义较为明确，但不唯一。<a href="#fnref:2" rev="footnote"> ↩︎</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.mbalib.com/wiki/%E9%9C%80%E6%B1%82%E6%8B%89%E5%8A%A8%E5%9E%8B%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">MBA 智库: 需求拉升型通货膨胀</a><a href="#fnref:3" rev="footnote"> ↩︎</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.mbalib.com/wiki/%E8%8F%B2%E5%88%A9%E6%99%AE%E6%96%AF%E6%9B%B2%E7%BA%BF">MBA 智库: 菲利普斯曲线</a><a href="#fnref:4" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何在 Minecraft 设计经济系统是一个服务器维护人员以及策划组持久讨论的问题，那么过了这么多年我能给出什么方案？&lt;/p&gt;</summary>
    
    
    
    <category term="学习" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="笔记" scheme="https://blog.krysztal.dev/categories/%E5%AD%A6%E4%B9%A0/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Minecraft" scheme="https://blog.krysztal.dev/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>TinyRemapper笔记</title>
    <link href="https://blog.krysztal.dev/2023/06/23/TinyRemapper%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.krysztal.dev/2023/06/23/TinyRemapper%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-23T21:19:20.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录一下探索 TinyRemapper 和 FabricMC 构建流程</p><span id="more"></span><h2 id="tinyremapper-是什么">TinyRemapper 是什么</h2><p>这是一个隶属于 FabricMC 的构建流水线(<em>Build Pipelines</em>)的一部分，TinyRemapper 可以对 JAR 应用 <code>Tiny</code> 映射格式(<em>Remapping format</em>)。</p><div class="note note-success">            <p>映射，顾名思义就是把一个东西等价称为另外一个东西。</p><p>关于为什么会有这个东西，是因为开发商对 JAR 构建结果应用保护措施而产生，在本文不再赘述。</p>          </div><p>在应用完毕后，我就可以让名为 <code>A</code> 的函数名可以称之为 <code>getBlock</code> ，<strong>这对反混淆来讲非常重要，而这是反混淆的最基础能力</strong>。</p><h2 id="fabricmc-build-pipelinesfabricmc-构建流水线">FabricMC Build Pipelines：FabricMC 构建流水线</h2><p>在这一部分需要单独提出，这对于理解 TinyRemapper 的功能与作用非常重要。</p><pre><code class=" mermaid">graphloom(FabricLoom Build Logic)--构建--&gt;YarnMappedBytecode--TinyRemapper应用Yarn到中间名映射--&gt;IntermediaryMappedBytecode--TinyRemapper应用中间名到原始名映射--&gt;TargetBytecodesrc(模组源代码)--&gt;loomlib(YarnMappedMinecraft)--&gt;srcmc(Minecraft)--TinyRemapper应用原始名到中间名的映射--&gt;IntermediaryMappedMinecraft--TinyRemapper应用中间名到Yarn的映射--&gt;lib</code></pre><p>可以看出 TinyRemapper 负责的部分是把我们可读的代码重新映射成 JVM 虚拟机内执行需要的代码，或者帮我们把我们读不懂的代码重新映射成我们能读懂的代码。</p><p>在 JVM 程序执行机制里，我们运行的 Minecraft 程序是使用原始名，这对我们来讲是几乎不可读的。Yarn 提供了一套标准的、自由的名称，让我们的体验更加顺畅。如果我们在模组里面调用了 Minecraft 的某个函数，对于 JVM 而言是 <code>INVOKE*</code> 命令<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="包含 `INVOKEVIRTUAL`，`INVOKESPECIAL`，`INVOKESTATIC`，`INVOKEINTERFACE`，`INVOKEDYNAMIC`">[0]</span></a></sup> ，而这些命令的参数其实是 Minecraft 的原始名，比如 <code>aabb/26390</code> 。</p><p>但是我们其实不会这样写，我们写的通常是类似 <code>world.getBlock</code> 这样的代码。</p><p>在完成编译后，JVM 居然能应用正确的参数。</p><p>这其中发生了什么？</p><h3 id="反混淆">反混淆</h3><p>顾名思义，反混淆就是把混沌的东西变成我们可以读懂的玩意儿</p><p>首先我们需要清楚，Mojang 在最早是不给我们提供资料的，我们只有猜。并且不是因为 Minecraft 才出现的反混淆，这是自 JVM 与 Java 诞生之初推广成功后便产生的东西。</p><p>在我们猜到这个非常混沌的方法名 <code>26390</code> 的大概作用后，我们就可以给他一个有意义的名字，并且记录下来。</p><p>记录下来后，映射便诞生了。</p><h3 id="重映射重混淆">重映射（重混淆）</h3><p>我们使用一些手段对字节码应用映射，这样我们就能顺利的写出 <code>world.getBlock</code> 这样的代码了，而不需要和 <code>abjxc1.asobb</code> 这样诡异的东西作斗争。</p><p>可是问题来了，我们前面说了，实际上这样做字节码指令的参数是不对的，是 <code>world/getBlock</code> ，JVM 是找不到 ClassPath 的——因为根本没有这个东西。</p><p>我们需要使用一个工具，用一种手段，和反混淆相反的手段，来纠正这些 ClassPath 和字节码指令参数，不如就叫做...<strong>重映射</strong>吧！</p><p>在经过这个流程后，我们的代码编译出来的模组终于可以被 JVM 正常加载，以及正常加载调用 Minecraft 的函数了。</p><h3 id="中间名的诞生">中间名的诞生</h3><p>在经过长期的经验中我们发现了一个大问题——他奶奶的，Mojang 一张混淆表给他妈的用的天荒地老<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="起码从 1.7.10 到现在没有变过">[1]</span></a></sup>。</p><p>而且两个版本之间经常一堆代码不变，那我是不是只用在意两个版本之间的新增和减少？</p><p>不对啊，聪明点的人肯定能想到这个玩意儿，而且早就在搞了。</p><p>确实是这样，并且 Yarn，MCP，Spigot 更新流程都是这样的。</p><p>问题是假如，我的意思是假如，假如我 Minecraft 的两个版本更新过快，你没时间反应，阁下又当如何应对？</p><p>又比如说，我需要编译前扫描整个 Minecraft 的字节码提取有用的信息，那编译可真的太慢了。</p><p>那我干脆直接早点提出来，要用的时候直接加载，快不快？非常快。</p><p>我假如说，我想 Mojmap 和 Yarn 混用，阁下又当如何应对？</p><p>没错，我会做一个转接层，而 Minecraft 反混淆后的各种方法名，字段名，类名，就叫做<strong>中间名</strong>！</p><p>然后我一视同仁，我把依赖的模组，全部用中间名转换成我想用的映射名，非常完美。</p><h2 id="理解-tiny-格式">理解 Tiny 格式</h2><p>TinyRemapper 有它们自己的格式，这是这个笔记的重点</p><p>这篇笔记以 1.19.4 的 <a href="https://raw.githubusercontent.com/FabricMC/intermediary/master/mappings/1.19.4.tiny">tiny 文件</a>为例</p><p>第一行可以直接忽略，我们称之为 <code>TinyRemapper Metadata</code></p><p>从第二行开始，就全是我们的主角了。</p><p>从分析角度来看，整个 tiny 文件格式应该以行为分析单位，因此我们也会以行作为例子来分析。</p><p>同时我也会用 Rust 代码来表达应有的储存结构，使用 TinyRemapper 的解析逻辑作为分析依据。</p><h3 id="class">CLASS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tiny">CLASS    a    net/minecraft/class_4581<br>│───│   │─│   │──────────────────────│<br>  │      │             │<br>  │      │             │<br>  │      │             │<br>  │      │             └──────── 完全限定名<br>  │      └────────────────────── 归属文件（混淆名）<br>  └───────────────────────────── `CLASS` 类型描述<br></code></pre></td></tr></table></figure><p>对于这行的解析，我会把他用 Rust 代码表述为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Class</span> &#123;<br>    obf_name: <span class="hljs-type">String</span>,<br>    intermediary_name: <span class="hljs-type">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的 Java 代码为<a href="https://github.com/FabricMC/tiny-remapper/blob/fa0c4e72f6ce434e91b0adbcc82a9b021eed6cc3/src/main/java/net/fabricmc/tinyremapper/TinyUtils.java#L234-L237">这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;CLASS&quot;</span>.equals(type)) &#123;<br>    out.acceptClass(splitLine[<span class="hljs-number">1</span> + fromIndex], splitLine[<span class="hljs-number">1</span> + toIndex]);<br>    <span class="hljs-keyword">if</span> (obfFrom != <span class="hljs-literal">null</span> &amp;&amp; !splitLine[<span class="hljs-number">1</span> + fromIndex].isEmpty()) obfFrom.put(splitLine[<span class="hljs-number">1</span>], splitLine[<span class="hljs-number">1</span> + fromIndex]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="field">FIELD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tiny">FIELD    b    F    a    field_21633<br>│───│   │─│  │─│  │─│   │─────────│<br>  │      │    │    │         │<br>  │      │    │    │         └── 中间名<br>  │      │    │    └──────────── 混淆名<br>  │      │    └───────────────── 类型方法描述符<br>  │      └────────────────────── 归属文件<br>  └───────────────────────────── `FIELD` 类型描述<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Field</span> &#123;<br>    class: <span class="hljs-type">String</span>,<br>    type_desc: <span class="hljs-type">String</span>,<br>    obf_name: <span class="hljs-type">String</span>,<br>    intermediary_name: <span class="hljs-type">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="method">METHOD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tiny">METHOD    a    (F)Lorg/joml/Quaternionf;    a    method_46349<br>│────│   │─│   │───────────────────────│   │─│   │──────────│<br>  │       │                 │               │          │<br>  │       │                 │               │          └ 中间名<br>  │       │                 │               └─────────── 混淆名<br>  │       │                 └─────────────────────────── 返回值方法描述符<br>  │       └───────────────────────────────────────────── 归属文件<br>  └───────────────────────────────────────────────────── `METHOD` 类型描述<br></code></pre></td></tr></table></figure><p>METHOD 和 FIELD 的处理逻辑是是一样的，所以直接看 <code>CLASS</code> 描述类型的代码就行。</p><p>对应的 Rust 代码为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Method</span> &#123;<br>    class: <span class="hljs-type">String</span>,<br>    return_desc: <span class="hljs-type">String</span>,<br>    obf_name: <span class="hljs-type">String</span>,<br>    intermediary_name: <span class="hljs-type">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>除此之外，tiny 还有注释，是以 <code>#</code> 开头的。</p><p>以上代码的描述与处理我放在了 <a href="https://gist.github.com/Krysztal112233/6e1c9d90f193e44ce725bc39c914426c">Gist</a> 上，需要可以自行参考。</p><!-- 引用 --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">包含 <code>INVOKEVIRTUAL</code>，<code>INVOKESPECIAL</code>，<code>INVOKESTATIC</code>，<code>INVOKEINTERFACE</code>，<code>INVOKEDYNAMIC</code><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">起码从 1.7.10 到现在没有变过<a href="#fnref:1" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下探索 TinyRemapper 和 FabricMC 构建流程&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://blog.krysztal.dev/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="分析" scheme="https://blog.krysztal.dev/categories/%E7%BC%96%E7%A8%8B/%E5%88%86%E6%9E%90/"/>
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="学习" scheme="https://blog.krysztal.dev/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Minecraft" scheme="https://blog.krysztal.dev/tags/Minecraft/"/>
    
    <category term="FabricMC" scheme="https://blog.krysztal.dev/tags/FabricMC/"/>
    
  </entry>
  
  <entry>
    <title>MicroOS：进阶</title>
    <link href="https://blog.krysztal.dev/2023/06/12/MicroOS%EF%BC%9A%E8%BF%9B%E9%98%B6/"/>
    <id>https://blog.krysztal.dev/2023/06/12/MicroOS%EF%BC%9A%E8%BF%9B%E9%98%B6/</id>
    <published>2023-06-12T18:20:19.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>知道了 MicroOS 的基本理念，那么就该用这些基本理念构建服务了。</p><span id="more"></span><h2 id="运行服务">运行服务</h2><p>对于服务的运行，在 MicroOS 上更倾向使用容器方案，但是如果你要使用 <code>Systemd</code> 也是可以的，毕竟 MicroOS 只是保证了系统的事务性，只要有办法持久化数据即可.</p><p>对于这一点，你需要一些容器编排软件，比如说:</p><ul><li>K8S</li><li>Docker Compose</li><li>Podman</li></ul><p>当然，就算是用这些东西，也要注意整个系统是事务化的，需要用新的快照来保存。</p><h2 id="数据持久化">数据持久化</h2><p>对于数据持久化，这是一个重头戏，从各种意义上来讲使用了 MicroOS 的服务器并不适合持久化储存数据，而你需要为你的 MicroOS 服务器配备一些能帮助他储存的东西，比如说 NFS.</p><h3 id="nfs">NFS</h3><p>这是我最推荐的方式，只要配置好 MicroOS 的 NFS 自动挂载，保证 NFS 主机不会宕机，那么基本上可以保证万全.</p><p>记住，你得好好配置 NFS 的权限和设置，不然的话越权访问了你的 MicroOS 就会互相感染._即使它们会自动恢复，但是数据无价_</p><h3 id="ftp">FTP</h3><p>非常不推荐，有这个想法可以直接跳过了.</p><h2 id="系统升级">系统升级</h2><p>忘记我重复提起的所谓事务性了吗？也就是说升级系统是一件事务，你需要在新的快照层上进行更改。</p><p>意思是实际上需要以下步骤：</p><ul><li>创建新的事务</li><li>执行软件包更新</li><li>保存事务</li><li>重启，验证是否正常工作（HealthCheck）</li></ul><h2 id="结语">结语</h2><p>这只是个非常非常细碎的笔记，其实记录到这里已经差不多了。关于系统的缩放性这不是我能讲的，权当是我自己的笔记罢了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;知道了 MicroOS 的基本理念，那么就该用这些基本理念构建服务了。&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/"/>
    
    <category term="系统" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="运维" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E7%B3%BB%E7%BB%9F/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://blog.krysztal.dev/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="MicroOS" scheme="https://blog.krysztal.dev/tags/MicroOS/"/>
    
  </entry>
  
  <entry>
    <title>MicroOS：起步</title>
    <link href="https://blog.krysztal.dev/2023/05/15/MicroOS%EF%BC%9A%E8%B5%B7%E6%AD%A5/"/>
    <id>https://blog.krysztal.dev/2023/05/15/MicroOS%EF%BC%9A%E8%B5%B7%E6%AD%A5/</id>
    <published>2023-05-15T18:46:29.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>MicroOS 是 SUSE 旗下一款很新的系统，面向原子化与自动化维护。</p><p>那么该从何体会它的好？它是为什么而诞生的？</p><span id="more"></span><h2 id="特性">特性</h2><ul><li>作为一款面向云端高效稳定的服务器操作系统，秉持容器第一的原则：程序服务均在容器上运行</li><li>为了保证系统运行的稳定性，操作系统的根文件为只读</li><li>有健康检查机制 <a href="https://github.com/kubic-project/health-checker">Health Checker</a> 确认当前运行的操作系统工作正确——如果工作不正确，则自动切换到上一个快照保证系统正确。而当添加了其他的需要验证正确性的服务，只需要给健康检查机制编写新的插件即可</li><li>采用事务性更新机制 <a href="https://kubic.opensuse.org/documentation/transactional-update-guide/transactional-update.html">Transactional Updates</a> 更新系统，而不影响当前运行中的系统</li></ul><h2 id="步入-microos-的第一步">步入 MicroOS 的第一步</h2><p>面对这样一个理念几乎全新的系统，需要重新了解一些特性才能正确的搞懂它</p><h3 id="重新整理理念">重新整理理念</h3><h4 id="系统的不可变性">系统的不可变性</h4><p>在普通的操作系统，比如最基本的 Debian 与 Ubuntu 与 Arch，更新操作系统往往会导致<strong>当前</strong>的操作系统的「文件系统」发生更改</p><p>而对于 MicroOS 来讲，更新系统并不会更新到当前正在运行的系统之上，而是在当前运行的系统之上建立一层新的「文件系统」，在下一次启动操作系统的时候才会应用最新的「文件系统」</p><h4 id="软件与服务">软件与服务</h4><p>对于 MicroOS，软件更倾向于<strong>系统层面</strong>的工具，而服务从由 Systemd 接管的部分更改为由容器运行时管理的<strong>容器</strong></p><p>这对于普通的发行版是由一定的区别的。普通的发行版往往是把它们混杂在一起，软件是服务，服务也是软件</p><h4 id="可伸缩性">可伸缩性</h4><p>对于 MicroOS，其保证了尽可能快的启动，因此相比与普通的发行版，MicroOS 更能适合需要伸缩的大型系统</p><h4 id="批量部署">批量部署</h4><p>MicroOS 提供了一个批量部署工具，能让系统管理员可以快速的大规模部署 MicroOS</p><h3 id="系统维护">系统维护</h3><p>对于 MicroOS 的系统，其使用了 openSUSE Leap 或者 openSUSE Tuwbleweed，也就是其基础系统的系统套件取决于你选择了基于哪个发行版的 MicroOS（基本上都是 Tuwbleweed）</p><h4 id="软件包">软件包</h4><p>如果你需要在基础系统上进行操作，你需要使用 <code>transactional-update pkg</code> 命令取代 openSUSE 的 <code>zypper</code> 命令</p><p>在对系统完成软件更新更改之后，需要使用 reboot 更换到最新的系统——这一点与 NixOS 极其类似，但是 MicroOS 采用的是 Btrfs 快照保证的原子化，而 NixOS 选择的是挂载不同的 nix store 来实现</p><h4 id="修改配置">修改配置</h4><p>如果你要修改系统的配置，类似 <code>/etc</code> 这些放配置文件的地方，你需要使用 <code>transactional-update shell</code> 进入一个新的可变快照里面——这个快照会在下一次重启时应用，或者使用 <code>transactional-update apply</code> 提前应用（不推荐）</p><h4 id="自维护">自维护</h4><p>什么叫做自维护？自动维护指的是不需要人工干预，系统即可实现自己对自己进行维护——比如说系统没有正常启动，那么系统将会进入自维护模式尝试让自己启动成功</p><p>听起来很神奇，但是原理其实很简单</p><p>还记得 MicroOS 有一个健康检查的工具套件吗？它预置了基础系统需要检查用的脚本，如果这些脚本执行后返回的值都是 0，那么证明系统启动成功；反之如果有一个返回了其他值，那么证明系统没有启动成功，MicroOS 会进行自回滚：回滚到以前的快照，直到有一个快照健康检查正常</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MicroOS 是 SUSE 旗下一款很新的系统，面向原子化与自动化维护。&lt;/p&gt;
&lt;p&gt;那么该从何体会它的好？它是为什么而诞生的？&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/"/>
    
    <category term="系统" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="运维" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E7%B3%BB%E7%BB%9F/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://blog.krysztal.dev/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="MicroOS" scheme="https://blog.krysztal.dev/tags/MicroOS/"/>
    
  </entry>
  
  <entry>
    <title>Swapfile 指北</title>
    <link href="https://blog.krysztal.dev/2023/01/29/Swapfile%20%E6%8C%87%E5%8C%97/"/>
    <id>https://blog.krysztal.dev/2023/01/29/Swapfile%20%E6%8C%87%E5%8C%97/</id>
    <published>2023-01-29T01:23:30.000Z</published>
    <updated>2024-09-22T11:36:37.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>swapfile 和 swap 是同种东西，都是<strong>虚拟内存</strong>。不过各有优劣，需要按照自己的需求选择。</p><span id="more"></span><p>本文不提供创建 swapfile 和 swap 分区的教程，但是提供你可能会用到的文档链接</p><h2 id="概念">概念</h2><p>这个东西在 Windows 和 Linux 上的叫法其实不太一样，但是功能是一致的</p><ul><li>Windows 和 macOS 上可能叫做交换文件，虚拟内存</li><li>Linux 上一般只叫做 swap 或者交换内存</li></ul><p>下文全部叫做交换内存或者 swap</p><h2 id="使用分区还是使用文件">使用分区？还是使用文件？</h2><p>使用分区可以在你有一个十分高速的磁盘上将整个磁盘都规划为交换内存，在这种情况下优势是：没有文件系统的额外开销，内核是直接将硬盘作连续的内存空间使用的</p><p>但是有些时候你会需要更加灵活的操作，这个时候你需要使用一些文件系统上的开销，创建一个 swap 文件即可</p><p>下表可以一眼看出优势和劣势</p><table><thead><tr class="header"><th style="text-align: center;">swap 方案</th><th style="text-align: center;">优势</th><th style="text-align: center;">劣势</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">分区</td><td style="text-align: center;">性能最好</td><td style="text-align: center;">不灵活</td></tr><tr class="even"><td style="text-align: center;">文件</td><td style="text-align: center;">灵活</td><td style="text-align: center;">性能稍差</td></tr></tbody></table><h3 id="分区方案">分区方案</h3><p>常见于自己电脑安装 Linux 发行版时发行版默认创建的 2GB 大小 swap 分区</p><p>这种 swap 方案往往是发行版自行管理的<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Debian 论坛：swap 分区](https://forums.debian.net/viewtopic.php?t=146429)">[0]</span></a></sup>，并且推荐至少有 2GB 大小的 swap 分区</p><p>不过也可以自己来挂载额外的一块 swap 分区，这种分区一般推荐是在单独的一块高速硬盘上</p><h3 id="文件方案">文件方案</h3><p>这种方案十分灵活，比如你可以在根目录下创建一个 <code>.swapfile</code>，并且把它使用 <code>mkswap</code> 命令格式化成为一个 <code>swapfile</code></p><p>接下来就出现了两个分支了<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DebianWiki](https://wiki.debian.org/Swap)">[3]</span></a></sup></p><ol type="1"><li>通过 <code>swapon</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[swapon 命令的 man 手册](https://linux.die.net/man/8/swapon)">[1]</span></a></sup> 命令临时挂载起来作为 swap 使用</li><li>写入到 <code>/etc/fstab</code> 使得系统可以在开机的时候自动挂载成为 swap</li></ol><h3 id="备选">备选</h3><p>什么，备选方案？有！</p><p>你想一下，这个世界上存在一些原地压缩与解压的算法比如 <code>lzo</code> 和 <code>lz4</code>，他们不消耗内存并且可以压缩数据</p><p>内存也是数据，为什么不能压缩？</p><p>那我使用这些压缩算法压缩内存不就变相扩大了内存？好聪明！</p><p>但是这种操作的代价就是一旦进入 swap 了会消耗更多的 CPU 资源，这种技术就叫做 <code>zram</code></p><p>很多发行版提供了对应的工具比如 <code>zram-tools</code></p><!-- reference --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://forums.debian.net/viewtopic.php?t=146429">Debian 论坛：swap 分区</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://linux.die.net/man/8/swapon">swapon 命令的 man 手册</a><a href="#fnref:1" rev="footnote"> ↩︎</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.debian.org/Swap">DebianWiki</a><a href="#fnref:3" rev="footnote"> ↩︎</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.debian.org/ZRam">DebianWiki: Zram</a><a href="#fnref:4" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;swapfile 和 swap 是同种东西，都是&lt;strong&gt;虚拟内存&lt;/strong&gt;。不过各有优劣，需要按照自己的需求选择。&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.krysztal.dev/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GPG物理密钥的安装与密钥的迁移</title>
    <link href="https://blog.krysztal.dev/2022/06/22/GPG%E7%89%A9%E7%90%86%E5%AF%86%E9%92%A5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
    <id>https://blog.krysztal.dev/2022/06/22/GPG%E7%89%A9%E7%90%86%E5%AF%86%E9%92%A5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%BF%81%E7%A7%BB/</id>
    <published>2022-06-22T11:20:05.000Z</published>
    <updated>2024-09-22T11:36:37.480Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自从买到了心心念念的偶尔才有货的 CanoKey 后就想着怎么发挥我能用到的它的所有功能，配置好一些网站的 <code>2FA</code> 后就咸鱼了。</p><p>然后我发现他可以保存 OpenPGP 密钥，作为 GPG 的物理密钥。</p><span id="more"></span><h2 id="前置要求">前置要求</h2><ul><li>需要一个 OpenPGP 支持的 Smartcard，比如 CanoKey，Yubikey。由于 Yubikey 价格过高，我选择的是开源平替 <a href="https://canokeys.org/">CanoKey</a></li><li>提前安装好 Gpg4Win 之类的 OpenPGP 工具。当然你也可以使用 Git 内自带的 GPG</li><li>能识别你的硬件的电脑或者硬件（</li></ul><h2 id="思路">思路</h2><p>我们需要做以下事情：</p><ul><li>初始化硬件</li><li>生成子密钥</li><li>备份主密钥</li></ul><h3 id="初始化-smartcard后文称之为物理密钥">初始化 Smartcard（后文称之为物理密钥）</h3><p>经过如下步骤处理可以获得初始化完毕的物理密钥，当然敏感信息也会脱敏。</p><h4 id="获取是否能正确识别到物理密钥">获取是否能正确识别到物理密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gpg --card-edit<br><br>Reader ...........: canokeys.org OpenPGP PIV OATH 0<br>Application ID ...: ******<br>Application <span class="hljs-built_in">type</span> .: OpenPGP<br>Version ..........: 3.4<br>Manufacturer .....: unknown<br>Serial number ....: ******<br>Name of cardholder: [not <span class="hljs-built_in">set</span>]<br>Language prefs ...: [not <span class="hljs-built_in">set</span>]<br>Salutation .......:<br>URL of public key : [not <span class="hljs-built_in">set</span>]<br>Login data .......: [not <span class="hljs-built_in">set</span>]<br>Signature PIN ....: forced<br>Key attributes ...: rsa2048 rsa2048 rsa2048<br>Max. PIN lengths .: 64 64 64<br>PIN retry counter : 3 3 3<br>Signature counter : 0<br>Signature key ....: [none]<br>Encryption key....: [none]<br>Authentication key: [none]<br>General key info..: [none]<br><br>gpg/card&gt;<br><br></code></pre></td></tr></table></figure><p>如果你的输出和我的差别不大，那么意味着你的物理密钥已经被系统识别到了。</p><h4 id="初始化你的物理密钥">初始化你的物理密钥</h4><p>这一步推荐阅读 <a href="https://wiki.debian.org/Smartcards/OpenPGP">Debian Wiki - Smartcards OpenPGP#Initialise the smartcard</a></p><p>简而言之，你需要设置你的物理密钥的</p><ul><li>用户名</li><li>语言</li><li>Reset Code</li><li>Admin PIN</li><li>PIN</li></ul><h3 id="生成主密钥">生成主密钥</h3><p>由此可知，你需要先生成主密钥。这一步推荐根据 <a href="https://keyring.debian.org/creating-key.html">Debian Wiki - Creating a new GPG key</a> 做。</p><p>当你完成了生成主密钥，那么你接下来需要生成子密钥，而主密钥必须要离开你的设备进行保存。</p><h3 id="生成子密钥">生成子密钥</h3><p>你需要生成三个子密钥，分别是认证(C)，签名(S)，加密(E)。</p><p>输入以下命令开始创建三个子密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gpg --edit-key --expert [Your Key ID]<br><br>******<br><br>gpg&gt; addkey<br>Key is protected.<br>...<br>&gt; 选 RSA (sign only)。<br><br>******<br><br>gpg&gt; addkey<br><br>&gt; 选RSA (encrypt only).<br><br>******<br><br>gpg&gt; addkey<br><br>&gt; 选RSA (<span class="hljs-built_in">set</span> your own capabilities)<br>&gt; 选中 S 和 E 去选掉他们，然后选中 A<br><br>******<br><br>gpg&gt; save<br></code></pre></td></tr></table></figure><p>子密钥生成后，我们需要做两件很重要的事情——生成吊销证书，搬家密钥到安全的地方。</p><h3 id="生成吊销证书">生成吊销证书</h3><p>当你的主密钥泄漏的时候，你需要吊销你的主密钥，这个时候吊销证书就会派上用场了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --output revoke.asc --gen-revoke &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>这个<strong>证书需要妥善保管</strong>，不然任何摸到他的人都能让你的密钥失效。</p><h3 id="备份你的所有密钥">备份你的所有密钥</h3><p>你的密钥应当全部拥有备份，备份或许可以打印出来，或许可以放到离线储存介质上。</p><p>总之备份应当足够的安全离线，要是你想可以让安保机构帮你保管。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --output privkey.sec --export-secret-key &lt;Your Key ID&gt;<br>gpg --armor --output subkeys.sec --export-secret-subkeys &lt;Your Key ID&gt;<br>gpg --armor --output pubkey.asc --<span class="hljs-built_in">export</span> &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>导出的私钥与公钥应当妥善保管，你的保存介质<strong>应当得到妥善保管</strong>，包括你的吊销证书。</p><p>也就是说你需要备份以下四个东西。保护好他们</p><ul><li>revoke.asc</li><li>privkey.sec</li><li>subkeys.sec</li><li>pubkey.asc （可以选择不备份他，因为他是公钥）</li></ul><h3 id="让主密钥离线">让主密钥离线</h3><p>在完成以上内容后，你应当命令你的主密钥离线。如果你有另外一个物理密钥的话（下文称之为第二物理密钥），你可以选择把你的主密钥传到第二物理密钥，然后把他妥善的保存好。如果你没有第二物理密钥的话，那么也无所谓，把上面导出的内容放到离线介质也是好的。</p><p>再次重复强调，这张第二物理密钥和保存密钥的介质应当长期离线，就算需要使用也应该在纯洁环境中使用。</p><h4 id="用第二物理密钥">用第二物理密钥</h4><p>简单说就是把当前的主密钥传输到一张智能硬件上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --expert --edit-key &lt;Your Key ID&gt;<br><br>gpg&gt; toggle<br>gpg&gt; keytocard<br>gpg&gt; save<br></code></pre></td></tr></table></figure><p>然后这张物理密钥就变成了保存你的主密钥的物理密钥，这张第二物理密钥应当平常不被使用，只有你需要再次签发新子密钥、更换密钥、注销子密钥的时候才使用。</p><h4 id="本地离线主密钥">本地离线主密钥</h4><p>只要我删掉主密钥不就行了吗？只要我导入只有子密钥的密钥不就行了吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --delete-secret-keys [Your Key ID]<br></code></pre></td></tr></table></figure><p>然后再次输入<code>gpg -K</code>，如果他没什么输出那就对了。</p><p>我们再导入上文导出的<code>subkeys.sec</code>就行了。</p><p>让我们再次输入<code>gpg -K</code>，如果你看到一个<code>sec#</code>那就证明做的很正确，主密钥成功离线。</p><h3 id="把子密钥搬家到物理硬件">把子密钥搬家到物理硬件</h3><p>输入以下命令进入编辑密钥模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --expert --edit-key &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>然后把前面三个子密钥都搬家到物理密钥上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg&gt; key [Sub Key ID]<br>gpg&gt; keytocard<br>&gt; 重复选中全部三个，并且都 keytocard<br>gpg&gt; save<br></code></pre></td></tr></table></figure><p>在完成以上步骤后，是否我们就结束了？</p><p>并不是，我们还需要导出一个<code>stub.asc</code>。这个文件并没有实质内容，他告诉 GPG 需要从物理密钥里面寻找所需要的密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --output stubs.asc --export-secret-keys &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>这个密钥可以随着你的常用介质走，导入到你需要的电脑上，他是安全的，因为不包含任何实际上的私钥。</p><p>同样的，推荐你把<code>pubkey.asc</code>和<code>stub.asc</code>放在一起。关于为什么下文会提到</p><h3 id="上传公钥">上传公钥</h3><p>你可以选择不做这步，因为上传公钥就能让全世界都能鉴定这是你。如果你是自己用的话就无所谓。</p><p>考虑到大多数情况下需要公开公钥，毕竟叫做 PubKey，所以推荐你做这一步。</p><p>现在的 KeyServer 会互相同步 Key，因此只需要简单的使用如下命令便可做到全世界的 KeyServer 都有你的 PubKey。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --send-key [Your Key ID]<br></code></pre></td></tr></table></figure><p>目前的 GPG KeyServer 默认为 <code>keyserver.ubuntu.com</code> ，是国内可以访问的，请放心食用捏。</p><p>上文提到的<code>pubkey.asc</code>为什么要和你的<code>stub.asc</code>放一起？因为一旦到了新设备，很可能新设备没联网，GPG 无法校验是否正确。</p><p>两个一起导入后 GPG 就能相信这是你了。</p><p>如果能联网哪？如果能联网，能与 KeyServer 通讯，并且已经上传了公钥，那么只需要做下面这一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --receive-key [Your Key ID]<br></code></pre></td></tr></table></figure><p>大功告成 uwu</p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://keyring.debian.org/creating-key.html">Debian Wiki - Creating a new GPG key</a></li><li><a href="https://wiki.debian.org/Smartcards/OpenPGP">Debian Wiki - Smartcards OpenPGP</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;自从买到了心心念念的偶尔才有货的 CanoKey 后就想着怎么发挥我能用到的它的所有功能，配置好一些网站的 &lt;code&gt;2FA&lt;/code&gt; 后就咸鱼了。&lt;/p&gt;
&lt;p&gt;然后我发现他可以保存 OpenPGP 密钥，作为 GPG 的物理密钥。&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/"/>
    
    <category term="杂文" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E6%9D%82%E6%96%87/"/>
    
    
    <category term="技术" scheme="https://blog.krysztal.dev/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/tags/%E6%8D%A3%E9%BC%93/"/>
    
  </entry>
  
  <entry>
    <title>用GPG签名告诉大家这就是我的提交</title>
    <link href="https://blog.krysztal.dev/2022/02/18/%E7%94%A8GPG%E7%AD%BE%E5%90%8D%E5%91%8A%E8%AF%89%E5%A4%A7%E5%AE%B6%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E6%8F%90%E4%BA%A4/"/>
    <id>https://blog.krysztal.dev/2022/02/18/%E7%94%A8GPG%E7%AD%BE%E5%90%8D%E5%91%8A%E8%AF%89%E5%A4%A7%E5%AE%B6%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E6%8F%90%E4%BA%A4/</id>
    <published>2022-02-18T14:14:24.000Z</published>
    <updated>2024-09-22T11:36:37.485Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>同学们早，大家签名 Commit 了吗？不签也可以，随便你。jpg</p><span id="more"></span><p>其实并不是我主动发现的这个功能，而是我看到了这些个洋葱新闻才发现了问题：</p><ul><li><a href="https://github.com/torvalds/linux/tree/8bcab0346d4fcf21b97046eb44db8cf37ddd6da0">Linus:我发现了那个叫做 WindowsXP 的系统很棒，Linux 是个垃圾系统</a></li></ul><p>好吧，还是搞搞 GPG 签名比较稳妥，虽然我的项目也不会有人这么搞就是了</p><div class="note note-success">            <p>本来这是 GitHub 很早前就有的漏洞了，他们说这个不影响。现在闹大了才勉强对这种情况标了个游离提交</p>          </div><p>Git 本身使用邮箱标注是谁的提交，这样就意味着可以随意冒充。但是新版本 Git 支持了 GPG 签名，这样就算 SSH Key 泄露了也能保证这个提交是你的了</p><div class="note note-success">            <p>Windows 的 git 已经包含了 GPG，不需要额外安装了。但是需要在 GitBash 下才能使用。不过 VSCode 也可以使用就是了</p>          </div><h2 id="验证是否已经有了-gpg-密钥">验证是否已经有了 GPG 密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --list-secret-keys --keyid-format LONG<br></code></pre></td></tr></table></figure><p>如果输出有的话，那么就不想要新建了</p><h2 id="新建-gpg-密钥">新建 GPG 密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --full-generate-key<br></code></pre></td></tr></table></figure><p>可以一路回车，输入邮箱之类的推荐用在 GitHub 验证过的</p><p>其实按照 GitHub 的工作原理的话，邮箱也必须是在 GitHub <strong>验证</strong>过的</p><div class="note note-warning">            <p>密钥长度这一项一定要写 4096 长度，这是 <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key">GitHub 的要求</a></p>          </div><h2 id="导出公匙">导出公匙</h2><h3 id="列出所有密钥">列出所有密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --list-secret-keys --keyid-format=long<br></code></pre></td></tr></table></figure><p>举个例子，假设它的输出为下面这样</p><p>当然，你能通过时间看出来谁是最新的，最新的那个当然是你想要的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gpg --list-secret-keys --keyid-format=long<br>/Users/hubot/.gnupg/secring.gpg<br>------------------------------------<br>sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]<br>uid                          Hubot<br>ssb   4096R/42B317FD4BA89E7A 2016-03-10<br></code></pre></td></tr></table></figure><h3 id="复制以-sec-开头的-gpg-密钥-id">复制以 sec 开头的 GPG 密钥 ID</h3><p>根据上面一条的输出，所以它的密钥 ID 为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">3AA5C34371567BD2<br></code></pre></td></tr></table></figure><h3 id="导出该-id-的公钥">导出该 ID 的公钥</h3><p>根据上一步，接下来我们的命令会变成这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --<span class="hljs-built_in">export</span> pub 3AA5C34371567BD2<br></code></pre></td></tr></table></figure><p>他会输出你的公钥，把它们全部粘贴复制到 GitHub 的 <a href="https://github.com/settings/keys">GPG Keys</a> 里面就行</p><h2 id="将-gpg-密钥与-git-关联">将 GPG 密钥与 Git 关联</h2><p>把上面的 ID 粘贴复制下来，输入下面这个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.signingkey 3AA5C34371567BD2<br></code></pre></td></tr></table></figure><p>然后我们需要让 Git 默认用 GPG 签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global commit.gpgsign <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>大功告成</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同学们早，大家签名 Commit 了吗？不签也可以，随便你。jpg&lt;/p&gt;</summary>
    
    
    
    <category term="捣鼓" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/"/>
    
    <category term="杂文" scheme="https://blog.krysztal.dev/categories/%E6%8D%A3%E9%BC%93/%E6%9D%82%E6%96%87/"/>
    
    
    <category term="Git" scheme="https://blog.krysztal.dev/tags/Git/"/>
    
  </entry>
  
</feed>
