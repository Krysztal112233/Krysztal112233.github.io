<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JWT 小册</title>
    <link href="/2024/02/21/JWT-%E5%B0%8F%E5%86%8C/"/>
    <url>/2024/02/21/JWT-%E5%B0%8F%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>JWT（JSON Web Token） 是一种分布式、跨域的单点登录方式，他开销很小而且天然支持分布式。</p><span id="more"></span><p>十分实用呐！<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[看看 jwt.io](https://jwt.io/)">[0]</span></a></sup></p><h2 id="结构">结构</h2><p>JWT 以 <code>.</code> 作为分割，储存以下内容</p><ul><li>Header：标识 JWT 的基本信息，比如算法等</li><li>Payload：负载，在这里会承载 JWT 的基础要素</li><li>Signature：签名，当 JWT 被恶意修改时将会无法验证，此时判定 JWT 失效</li></ul><p>举个例子，典型的 JWT 应该是长成下面这样子</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c<br></code></pre></td></tr></table></figure><h3 id="header">Header</h3><p>这里的字段是相对固定的：算法和 Token 类型</p><p>举个例子，使用 <code>HS256</code> 的算法的 JWT 的 Header 应该是如下样式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="payload">Payload</h3><p>常见的 Payload 字段有 7 个，所有的字段名都尽可能缩减为 3 个字母</p><p>如下表格即是 7 个标准 Payload 字段的定义以及是否可选</p><table><thead><tr class="header"><th style="text-align: center;">字段名</th><th style="text-align: center;">备注</th><th style="text-align: center;">是否可选</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">exp</td><td style="text-align: center;">过期时间</td><td style="text-align: center;">❎</td></tr><tr class="even"><td style="text-align: center;">iss</td><td style="text-align: center;">发布者</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">sub</td><td style="text-align: center;">主题</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">aud</td><td style="text-align: center;">接收者</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">nbf</td><td style="text-align: center;">在此之前不生效</td><td style="text-align: center;">✅</td></tr><tr class="even"><td style="text-align: center;">iat</td><td style="text-align: center;">发布时间</td><td style="text-align: center;">✅</td></tr><tr class="odd"><td style="text-align: center;">jti</td><td style="text-align: center;">JWT 的 ID</td><td style="text-align: center;">✅</td></tr></tbody></table><p>除此之外还有很多其他的常用字段<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Wikipedia JWT](https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields)">[1]</span></a></sup>。</p><h3 id="signature">Signature</h3><p>对于一串 Payload，我们使用密钥计算出他的签名，若是 Payload 被篡改那么签名也会不一致</p><p>如果签名不一致，那么就可以认为 Token 被篡改了</p><h2 id="签名算法">签名算法</h2><p>一般情况下使用 <code>HMAC</code> 足矣，但是有些为了特别安全的情况可以使用 <code>RSA</code> 或者 <code>ECDSA</code></p><h2 id="传输与储存方式">传输与储存方式</h2><p>JWT 可以储存在 HTTP 请求的 Header 里，这是最方便的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">Authorization: Bearer &lt;token&gt;<br></code></pre></td></tr></table></figure><p>当然，HTTP 是明文传输这是十分不安全的，所以应该是有加密层的传输最好。</p><p>除此之外，也可以填入在请求体的某个字段里，不过这不是推荐的方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;jwt&quot;</span><span class="hljs-punctuation">:</span> &lt;token&gt;<span class="hljs-punctuation">,</span><br>    ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><!-- reference --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://jwt.io/">看看 jwt.io</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/JSON_Web_Token#Standard_fields">Wikipedia JWT</a><a href="#fnref:1" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用密钥登录 SSH</title>
    <link href="/2024/01/31/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%20SSH/"/>
    <url>/2024/01/31/%E4%BD%BF%E7%94%A8%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95%20SSH/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>使用密钥登录远程服务器应该是最安全方便的操作，没有密钥对的私匙谁都不能上你的服务器。就算是暴力破解也不行。</p><span id="more"></span><p>但是，一定要记住，root 的密码无论如何也要是强密码。</p><h2 id="准备过程">准备过程</h2><p>首先确认你的计算机里有没有 SSH Key，如果有的话直接用就好，不需要再次生成(假设用 ED25519 算法，如果是 RSA 算法把 <code>ed25519</code> 改成 <code>rsa</code> 就好)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><p>如果是空的话就需要做下一步，如果不是的话就执行如下命令并且跳过下一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xclip -sel clip &lt; ~/.ssh/id_ed25519.pub<br></code></pre></td></tr></table></figure><p>这条命令的意思是把输出的东西传送到剪贴板里，Linux 很神奇罢！</p><h2 id="生成密钥对">生成密钥对</h2><p>TODO</p><h2 id="配置远程服务器允许使用密钥登录">配置远程服务器允许使用密钥登录</h2><p>登录到远程服务器，并且打开 <code>/etc/ssh/sshd_config</code> 文件，把如下内容的注释去掉</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">...<br>PubkeyAuthentication yes<br>...<br></code></pre></td></tr></table></figure><p>然后打开 <code>.ssh/authorized_keys</code> 这个文件，把剪切板里的东西复制进去，大功告成</p><h2 id="后记">后记</h2><ul><li><code>.ssh/</code> 的权限必须是 <code>700</code></li><li><code>.ssh/authorized_keys</code> 的权限必须是 <code>600</code></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Guava：Cache</title>
    <link href="/2023/10/18/Guava%EF%BC%9ACache/"/>
    <url>/2023/10/18/Guava%EF%BC%9ACache/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在开车的时候，与前方车辆一定要保持适当的距离，不管车速如何都是如此。这段距离叫做缓冲距离；在开发中也有类似的概念，不过分为 <code>Buffer</code> 和 <code>Cache</code>，<code>Cache</code> 偏向无序，<code>Buffer</code> 偏向有序。</p><span id="more"></span><h2 id="为什么要用-cache用-hashmap-不是更好">为什么要用 <code>Cache</code>？用 HashMap 不是更好？</h2><p>听着，我知道你很喜欢用 HashMap 也很喜欢自己造轮子。但是你要知道，你自己造的轮子大概率功能比不过 Guava 这种久经风霜的库，即使 Guava 非常的重并且非常的庞大。</p><p>为什么用 <code>Guava</code> 的 Cache？单纯就是方便。Guava 的 <code>Cache</code> 提供了以下非常吸引人的方面特性。</p><ul><li>从命令行式参数构建</li><li>过期时行为</li><li>多种驱逐方式</li></ul><p>即使 Guava 的 <code>Cache</code> 实现非常的简单，我们也没有必要去和 Guava 这种经历了长期考验的库看谁做的好。节约时间很重要。</p><h2 id="构建你的-cache-视图">构建你的 <code>Cache</code> 视图</h2><p>对于是否可以安全的在多个线程之间共享一个 <code>Cache</code>，答案是可以：<code>Cache</code> 最核心的实现其实是 <code>ConcurrentHashMap</code>，因此是线程安全的。</p><h3 id="选择驱逐模式-eviction">选择驱逐模式 (Eviction)</h3><p>Guava 的 <code>Cache</code> 提供了三种驱逐模式，适用于不同的场合。当然到底该用什么驱逐模式应该由开发者自己决定。</p><ul><li>基于时间的驱逐模式 <a href="https://github.com/google/guava/wiki/CachesExplained#timed-eviction">Timed Eviction</a></li><li>基于大小的驱逐模式 <a href="https://github.com/google/guava/wiki/CachesExplained#size-based-eviction">Size-based Eviction</a></li><li>基于引用的驱逐模式 <a href="https://github.com/google/guava/wiki/CachesExplained#reference-based-eviction">Reference-based Eviction</a></li></ul><p>请查阅给出的链接选择适合你的模式。对于一般项目来讲，最合适的是基于时间的驱逐模式以及基于大小的驱逐模式，基于引用的驱逐模式很少用，这种需要借助 GC 进行缓存驱逐的驱逐策略难判断什么时候会缓存穿透。</p><h3 id="缓存权重">缓存权重</h3><p>TODO</p><h3 id="驱逐时的监听器">驱逐时的监听器</h3><p>假设一个情景，你的缓存是一种面向反复查询数据库的缓存，你的缓存能暂时保存数据，并且在过期时写入缓存内的数据到数据库里。</p><p>这个时候，你就需要设计驱逐时的监听器了——驱逐时把缓存里的东西写到数据库里。</p><h2 id="其他建议">其他建议</h2><p>考虑到缓存有可能是需要异步的，但是 Guava 没有提供这种操作。所以 Guava 建议使用 <a href="https://github.com/ben-manes/caffeine">Caffeine</a> 这个项目。</p><p>不用担心，Guava <code>Cache</code> 和 <code>Caffeine</code> 项目的使用方法几乎一模一样。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>笔记</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译器笔记：增量编译</title>
    <link href="/2023/10/06/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/"/>
    <url>/2023/10/06/%E7%BC%96%E8%AF%91%E5%99%A8%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如何让编译程序尽可能的快？并行化编译是最原始的做法——让每个单元都互相独立编译，并且尽可能多地同时编译。更进阶的做法就是——增量编译。</p><span id="more"></span><h2 id="增量编译原理">增量编译原理</h2><p>增量编译的基础可以是并行化编译，也可以是串行编译。但是这只是过程，最重要的是能对每个文件进行单元化编译。</p><p>这是并行化编译的基础，从速度上考虑增量编译的单元应该是文件而不是文本内容，如果一个文件内容变化了一点但是需要大量的 <code>differ</code> 计算那我们不如直接从 0 开始编译。</p><h2 id="如何实现一个简单的增量编译">如何实现一个简单的增量编译</h2><p>我会用最简单的话来讲述实现增量编译的原理，甚至简单到不需要有太多编译相关的知识。</p><p>我们假定在 <code>.caches</code> 文件夹下有一个 <code>compile.json</code> 文件，用于记录上一次编译所产生的文件的信息：包含最小编译单元的 Digest（比如 MD5，SHA256），该单元输出的 Digest。</p><p>在编译文件时，先检查 <code>compile.json</code> 文件里是否有对应的信息：</p><ul><li>如果有的话<ul><li>检查编译单元的 Digest 是否发生变动（ Differ ）<ul><li>已经变动：重新编译并且记录最小编译单元的 Digest，记录该单元的编译输出的 Digest</li><li>没有变动：查找该单元是否已经编译过<ul><li>已经编译过并且编译输出的 Digest 和记录值相同则不作编译</li><li>没有编译输出或者编译输出的 Digest 发生变动则重新编译</li></ul></li></ul></li></ul></li><li>如果没有的话<ul><li>编译该编译单元，并且记录该编译单元的 Digest 和该编译单元的编译输出的 Digest</li></ul></li></ul><p>这样就是一个很简单的增量编译处理方式——输入没变就去找输出，输出变了就重新输出；输入变了那输出肯定和之前就不一样了。</p><p>这种处理方式有一个问题，那就是对于大项目来讲如果经历大重构会出现一大堆没办法被处理掉的之前的编译输出：因为这些编译输出已经是以前的文件的了，编译单元被重构后路径也发生了变化。</p><p>所以会有些文件不会被处理掉。</p><p>但我觉得问题不大，因为 <code>cleanBuild</code> 也是很必要的——而且各位的开发机也不缺这点储存。</p><p>用一个更直观的图来表达这个过程吧！</p><figure><img src="drawio.png" alt="" /><figcaption>流程图</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>笔记</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle秘境：添加一个类似modCompileOnly的依赖块</title>
    <link href="/2023/09/17/Gradle%E7%A7%98%E5%A2%83%EF%BC%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCmodCompileOnly%E7%9A%84%E4%BE%9D%E8%B5%96%E5%9D%97/"/>
    <url>/2023/09/17/Gradle%E7%A7%98%E5%A2%83%EF%BC%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCmodCompileOnly%E7%9A%84%E4%BE%9D%E8%B5%96%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>FabricLoom 里有类似 <code>modCompileOnly</code>、<code>modApi</code>、<code>modImplementation</code>、<code>modRuntimeOnly</code> 配置块，那应该怎么做才能在自己的 Gradle 插件里实现类似的功能？</p><span id="more"></span><p>假设：你已经会了 Kotlin，并且大概知道怎么使用 Gradle，并且 Gradle 的插件项目已经成功创建，并且可以成功被加载</p><h2 id="为什么要这么做那是什么">为什么要这么做？那是什么？</h2><p>先介绍一下 FabricLoom 这个 Gradle 插件的的 <code>modCompileOnly</code> 等配置块的功能。</p><p>这个配置块用于在 <code>dependencies</code> 块里描述一个新的依赖，但是 Gradle 会依赖你写的是 <code>implementation</code> 或者 <code>compileOnly</code> 而执行对应的功能。</p><p>举个例子，你会在 FabricLoom 项目的 build.gradle 里面看到类似这样的配置块：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    minecraft <span class="hljs-string">&quot;com.mojang:minecraft:$&#123;project.minecraft_version&#125;&quot;</span><br>    mappings <span class="hljs-string">&quot;net.fabricmc<span class="emoji" alias="yarn" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f9f6.png?v8">&#x1f9f6;</span>$&#123;project.yarn_mappings&#125;:v2&quot;</span><br>    modImplementation <span class="hljs-string">&quot;net.fabricmc:fabric-loader:$&#123;project.loader_version&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是你会发现，往往不需要再次声明一次对于 <code>net.fabricmc:fabric-loader:$&#123;project.loader_version&#125;</code> 这个依赖的 <code>implementation</code> 配置块。</p><p>这是为什么？因为 <code>modImplementation</code> 配置块继承了 <code>implementation</code> 配置块，所以在这项依赖被 <code>implementation</code> 配置块对应的处理器处理后，可以被 FabricLoom 再次收集信息，加入 Minecraft Client 的模组加载列表里面！</p><p>很好，这下应该解释清楚了为什么要做这项工作，那么我们的正事开始——设计新的 <code>plImplementation</code> 配置块，并且收集所有配置块的信息。</p><h2 id="代码实现">代码实现</h2><p>接下来的代码用 Kotlin 实现，所以前文需要假设你会 Kotlin（毕竟 Kotlin 不难）</p><p>先想清楚我们要做什么：添加一个叫做 <code>plImplementation</code> 的依赖块，可以写到 <code>dependencies</code> 块里，并且它可以被视为是正常的 <code>implementation</code> 块能被当作依赖处理。</p><h3 id="新增一个-configuration">新增一个 <code>configuration</code></h3><p>在 Gradle 插件进行注册的时候，我们把这段代码写到插件注册里去</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">configuration.register(<span class="hljs-string">&quot;plImplementation&quot;</span>) &#123;<br>    it.extendsFrom(configuration.getByName(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME))<br>    it.description = <span class="hljs-string">&quot;Extend from `implementation`, but it will add dependencies into `plugins` directory.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要成功运行那就是注册成功，这里通过 <code>it$extendsFrom</code> 说明了它是继承了 <code>implementation</code> 块。</p><h3 id="taskaction-里进行操作"><code>@TaskAction</code> 里进行操作</h3><p>在 <code>@TaskAction</code> 里我们这样写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">project.configurations<br>    .getByName(<span class="hljs-string">&quot;plImplementation&quot;</span>)<br>    .incoming<br>    .resolutionResult<br>    .allComponents<br>    .forEach &#123; result -&gt;<br>        result.dependencies.forEach &#123; dependency -&gt;<br>            project.logger.info(<span class="hljs-string">&quot;:<span class="hljs-variable">$PL_TASK_EVALUATE_PLUGIN</span>: <span class="hljs-variable">$dependency</span>&quot;</span>)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样就可以获取到如下 <code>plImplementation</code> 块的依赖了，并且对他进行额外处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">dependencies &#123;<br>    plImplementation(<span class="hljs-string">&quot;net.fabricmc:fabric-loader:<span class="hljs-subst">$&#123;project.loader_version&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>笔记</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minecraft：原始经济系统设计简述</title>
    <link href="/2023/08/26/Minecraft%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/"/>
    <url>/2023/08/26/Minecraft%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>如何在 Minecraft 设计经济系统是一个服务器维护人员以及策划组持久讨论的问题，那么过了这么多年我能给出什么方案？</p><span id="more"></span><h2 id="经济系统基础">经济系统基础</h2><p>首先需要了解经济系统的一般特性，在了解经济系统的一般特性后我们可以以此为理论基础进一步设计原始的经济系统<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MBA 智库：经济系统](https://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F)">[0]</span></a></sup></p><blockquote><p>(1)经济系统的整体性。经济系统是由相互联系和相互作用的若干经济元素结合而成的有机整体。各个经济元素与经济系统之间的关系是整体和部分的关系。各经济元素在功能上必须与经济系统整体适应，居于经济系统整体的从属地位。正是由于系统局部的统一性，才构成了系统的整体性。所以，我们在处理任何经济系统问题时，应坚持从经济系统的整体出发，从全局出发，发挥经济系统整体的特定功能和效益。</p><p>(2)经济系统的层次性。局部的独立性构成系统的层次性。经济系统的层次，指经济系统中各经济元素之间的地位、等级关系。它反映了经济系统是可以组合的，也是可以分解的。经济系统的各个组成部分既可以自成系统，又可以互为系统。不同层次或同一层次的经济元素既有共同的运行规律，又有各自的运行规律。经济系统的层次及其层次之间的关系说明经济系统具有多层次性。</p><p>(3)经济系统的结构性。经济系统的结构，指经济系统内部各个经济元素之间的相互联系和相互作用的结合形式。它反映了经济系统中各经济元素之间的比例关系、排列顺序和结合方式。合理的经济结构，能使经济系统具有生命力，更加协调地运行。一般来讲，经济系统结构具有相对的稳定性。对不合理的经济系统结构要进行调整，保持经济系统的合理运行。总之，经济系统的结构是否合理，关系到社会经济发展的战略问题，关系到经济系统特定功能与效益的发挥和提高问题。</p><p>(4)经济系统的开放性。开放性是针对封闭性而言的。开放系统是与其他系统进行物质、能量、信息交换的系统。自然界中存在的一切系统，几乎都是开放系统。完全与外界隔绝的孤立系统实际上并不存在。经济系统的开放性，指经济系统与物质、能量、信息等的相互关系。如果一个经济系统开放性很强，说明它与环境交换的物质、能量、信息的数量大，范围广泛，种类繁多。开放的经济系统既受到国内自然条件、生态环境、资源数量等自然环境的制约，又受到人口状况、经济体制和政策等社会经济环境的影响。所以，够开放的中国保持经济系统的开放性，非常必要。</p></blockquote><p>有了最原始的理论基础，接下来我们来细细分析这些理论基础能导出什么。</p><h3 id="经济系统的整体性">经济系统的整体性</h3><h4 id="什么叫做有机的整体">什么叫做有机的整体？</h4><blockquote><p>经济系统是由相互联系和相互作用的若干经济元素结合而成的有机整体</p></blockquote><p>经济系统是一个巨系统，一个系统是由多个不同的部分组成，而巨系统是由多个不同的系统组成。</p><p>什么是经济元素？元素就是构成新个体的基础要素，这里的定义为：信息、物质、能量、时间、空间<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这部分是微观经济元素，定义并不是很明确，只能暂时这么定义，并且这么定义是符合上下文的关系的。">[1]</span></a></sup>或个人、企业、政府、市场、资源<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这里是宏观的经济元素，定义较为明确，但不唯一。">[2]</span></a></sup>。</p><p>它们之间互相协调互相影响，最终到达一个稳定的点，成为一个有机系统。</p><p>比如：当一个物件使用原始的工艺需要<em>大量的时间</em>与<em>大量物质</em>去生产，改良后的工艺在生产该物件时可以<em>大幅度缩减该物件的时间要素与物质要素</em>，但我们需要投入更多的物质与时间到<em>改进工艺</em>这个步骤，因此在这一个生产流程之中产生了一个平衡：投入时间与物质到改进工艺，但生产物件所需要的时间与物质减少。</p><p>由于例子内的元素需求达到了一种有机平衡，从整条生产过程来看最终的结果是导致该物件的成本会被稀释，该物件若需求不变的情况下经济价值会变低。正是因为各个局部经济元素之间有一定程度的统一性和协调性，才会使得经济系统体现出一定的整体性。</p><blockquote><p>我们在处理任何经济系统问题时，应坚持从经济系统的整体出发，从全局出发，发挥经济系统整体的特定功能和效益</p></blockquote><p>这句话定义了一个分析任何经济系统问题的方法论，我们应该始终从整体角度出发，考虑全局因素，才能确保经济系统的稳定发展。</p><h4 id="举个例子">举个例子</h4><p>举个比较现实的例子，这种方法论也适合分析任何巨系统面临的问题。</p><blockquote><p>想象一个城市的交通系统作为一个例子。</p><p>在城市交通系统中，各种交通方式（汽车、公共交通、自行车等）构成了交通系统的各个经济元素。每种交通方式都有其特定的功能和效益，但它们需要与整个交通系统相适应，以确保城市内的流动性和效率。</p><p>各个交通方式之间的关系体现了整体和部分之间的关系。例如，交通信号灯、道路规划、公交车站等都是整个交通系统的一部分，它们的协调和协作对于整个系统的正常运行至关重要。</p><p>每种交通方式在功能上需要与整个交通系统整体适应。例如，公共交通系统需要根据人口分布和需求来安排线路，以满足市民的出行需求。同时，道路规划也需要考虑各种交通方式的流量，以保证交通的顺畅。</p><p>整个交通系统的整体性在于，各种交通方式共同构成了一个互相依赖的有机结构，城市的交通运行取决于这些交通方式的协调和平衡。如果某种交通方式出现问题，可能会影响整个系统的效率，导致交通拥堵等问题。</p></blockquote><p>从整体的方向（交通系统）分析了设计交通红绿灯、公交等局部系统的设计，最终达到解决问题的目标。</p><p>但是与此同时，一个系统瘫痪会影响到整体巨系统的效率，表现为交通拥堵。</p><h3 id="经济系统的层次性">经济系统的层次性</h3><h4 id="理解层次性">理解层次性</h4><p>这非常容易理解，最典型的为供应链，一种常见但是算比较复杂的经济系统。</p><p>接下来我把一个供应链的简化结构按照层次从第一层次到最终层次列举出来。</p><ul><li>原材料供应商：整个系统的基础，<strong>影响着上下游的产物基础价格</strong>。</li><li>制造商：它们会把原料组装成为最终的成品，它们的工艺以及运营和决策<strong>决定了了产品的质量和整条供应链的可靠性</strong>。</li><li>分销商与批发商：库存端，它们可以决定产品的管理和所有订单的的履行，<strong>决定了供应链的灵活性以及效率</strong>。</li><li>零售商：将产品推向市场，使其成为商品。从消费者收集信息（例如需求）反馈给上游，<strong>决定了整个供应链的规划</strong>。</li><li>消费者：最终消费端，是整个供应链的动力来源，<strong>供应链到底生产什么以及生产多少</strong>和他们的需求有关。</li></ul><h4 id="什么叫做每个层次也可以独立">什么叫做每个层次也可以独立？</h4><p>我们把"原料供应商"这一层次单独取出来解释，为什么<em>各个组成部分既可以自成系统，又可以互为系统</em>。</p><p>原料供应商中依然存在供应链关系：原料供应商从原料生产者获取原料，最终加工成为初级材料。</p><p>典型的例子为乳业，在奶产品供应链中有奶农，奶厂，消费者。</p><p>原材料供应商由奶农和收购方构成，那么问题来了，他们能不能构成独立的系统？答案是可以！</p><p>奶农自己生产牛奶，自己喝掉，<strong>自己既是原材料供应商，也是消费者</strong>。 也可以自己生产牛奶，送给朋友喝，<strong>自己是原材料供应商，朋友是消费者</strong>。</p><p>这只是个"原材料供应商"角度的例子，甚至消费端也是成立的：你把你买到的物品送给朋友，<strong>只要有输入</strong>就能让系统运行下去。</p><h3 id="经济系统的结构性">经济系统的结构性</h3><p>像是现实生活中的结构一样，结构是有稳定性，更是具有组成部分的。</p><h4 id="为什么经济系统需要一定的结构性">为什么经济系统需要一定的结构性？</h4><p>经济系统需要一定的结构性，如果生产端一直生产没有消费这是可能的吗？这很明显是不可能的，生产端需要需求才能确定生产量，这样生产端迟早会因为产品无法被消费而损毁。</p><p>再比如，一个国家不可以只有制造业生产部门，这样的结构单一性过重，容易受到其他国家的冲击。而产业结构会影响经济结构：全是服务部门，会导致只能在服务端消费循环。</p><p>我将会以一个国家典型的经济结构解释。</p><h4 id="理解为什么一个国家经济结构不能过于单一">理解为什么一个国家经济结构不能过于单一</h4><p>一个国家往往包含以下结构</p><ul><li>家庭（家庭部门）： 家庭在经济结构中占据重要地位，因为它们提供劳动力、消费品的需求以及储蓄。家庭部门通过劳动力市场提供劳动力，通过商品市场提供需求，同时也可能从金融市场获取收入。</li><li>企业（企业部门）： 企业在经济结构中是生产者，它们生产商品和提供服务。企业通过商品市场向家庭和其他企业销售产品，通过劳动力市场雇佣劳动力，通过金融市场筹集资金。</li><li>政府（政府部门）： 政府在经济结构中扮演多重角色，包括提供公共服务、征税、开支以及监管。政府通过金融市场筹集资金，通过政策影响其他部门的活动。</li><li>金融市场： 金融市场是各个部门进行资金交流的场所。家庭、企业和政府都可以在金融市场融资或投资，从而影响整体的经济活动。</li><li>商品市场： 商品市场是各个部门交换物品和服务的地方。家庭购买消费品，企业之间交换原材料和产品，这些交换构成了商品市场的一部分。</li></ul><p>如果一个国家彻底抹除了商品市场，那么这部分的结构往往需要由政府来承担，一个角色承担了过多的职能会导致不稳定：因为受到自身的影响过多，<strong>一旦政府停摆对应的商品市场也会停摆</strong>，造成消费品与商品无法交流，企业之间也无法交换原材料完成生产职能，典型的例子是前苏联与朝鲜。</p><p>如果一个国家抹除了企业，那么将会由市场（金融与商品）承担这部分职能：<strong>消费品将会完全依赖进口</strong>，本国（本经济体）不再具有生产能力，典型的例子是马达加斯加。</p><h3 id="经济系统的开放性">经济系统的开放性</h3><p>一个经济系统，只有生产没有其他经济系统的输入，现实吗？</p><p>一个经济系统，只有生产没有向其他经济系统输出，现实吗？</p><p>其实可以，叫做小农经济。</p><p>这种经济在没有外来干扰的情况下非常稳定，但是发展极其缓慢：因为无法提高生产力。</p><p>如果一个经济体有原材料输入，那么这个经济体可以提高生产力而不降低本国原材料端获取效率，生产出的产品（消费品）可以供国内消费，同时过多的可以输出到国外与其他经济体交换。</p><p>这就是为什么开放的经济系统更加具有生命力：<strong>它们更符合互通有无的特性</strong>。</p><h2 id="剖析-minecraft">剖析 Minecraft</h2><p>有了基础理论，我们可以开始剖析 Minecraft 和考虑实行的可行性了。</p><p>以下的考虑均基于 Vanilla Minecraft，而不是任何的 Modded Minecraft。</p><h3 id="vanilla-minecraft-里有什么玩家扮演了什么">Vanilla Minecraft 里有什么？玩家扮演了什么？</h3><p>玩家在游戏内可以承担多种角色：生产者，消费者，甚至是零售商。</p><p>每个玩家都可以是一个独立的系统：他们可以不去购买资源，完完全全自己获取资源。</p><p>最原始的资源为服务器地图中所能产生的资源：所有方块，所有奖励箱内的东西，所有玩家能获取到的物资。</p><p>玩家在初期则全部为资源获取者，他们都需要获取最原始的资源。</p><p>中期玩家是资源消费端，玩家需要不断的消耗资源，或者转换资源成为其他更少获得的资源。</p><p>在末期玩家会不断的出售自己的资源，将自己的资源出售转换成为虚拟货币，以备不时之需。</p><p>我们需要重新规划玩家的游戏历程，甚至破坏 Vanilla Minecraft 的游戏历程，让玩家不能快速地到达末期。</p><h3 id="分析游戏历程以及分析玩家的扮演阶段">分析游戏历程，以及分析玩家的扮演阶段</h3><p>在 Vanilla Minecraft，一个典型的流程为</p><pre><code class=" mermaid">graph LR主世界.-&gt;红石玩家开始研究红石机器主世界 --获取资源--&gt; 地狱 --获取资源以及强化装备--&gt; 末地 --获取翅鞘等--&gt;主世界地狱 --获取下界之星--&gt; 搭建信标搭建信标--&gt;毕业末地--获取龙蛋--&gt;毕业</code></pre><p>也就是说当玩家成功搭建完毕信标，或者获取到龙蛋，这个游戏的历程就结束了，玩家选择不再上线等等。</p><p>除此之外，玩家玩到无聊了就自然不上线了，这也是一种特例，因为是服务器本身的活力不足导致的问题，这种情况下应该鼓励玩家邀请朋友一起游玩，以及适当的福利以及适当的活动。（除了每日上线以及一些日常活动）</p><p>当然，红石玩家是特例，红石玩家不会有毕业的时候，并且是最大的资源生产大头以及消费大头。这部分玩家我们暂时不讨论，因为情况特殊。但是我们需要考虑一些特别的机制：刷怪塔等让某种资源获取效率发生极大变化的结构以及机制。</p><h3 id="结论">结论</h3><p>我们现在清楚了，服务器的资源情况取决于玩家当前进入了什么阶段，玩家进入了什么阶段也会影响该玩家在服务器的活跃程度。</p><p>还要考虑玩家之间交换物品的方式，因为原始的以物易物也是经济的一部分。</p><p>我们需要考虑的地方：</p><ul><li>玩家的游戏历程以及阶段</li><li>物品应该如何在玩家之间流通</li><li>物品的价值如何界定</li><li>稳定货币应该是什么</li><li>货币系统如何运作</li></ul><h2 id="货币系统基础">货币系统基础</h2><p>由于 Vanilla Minecraft 的经济系统为闭环系统，在不存在“无限收购”的前提下，玩家持有的货币始终等于“信用体系”总的货币，也就是所有玩家的资产加起来等于服务器总的资产，服务器需要负责承担“发行者”的角色——服务器货币的总量，取决于服务器愿意发行多少货币给玩家。</p><h3 id="通货膨胀通货紧缩">通货膨胀？通货紧缩？</h3><p>这是两个很重要的经济学现象，由于表达货币和需求之间的关系。</p><p>通货膨胀具体表现为货币贬值，但是货币贬值与通货膨胀实际为两种领域的现象，只是它们之间有相互的关联性。</p><p>用人话来讲，就是物价上升，人们的购买力减少。而通货紧缩则相反，物价下跌人们的购买力提升。</p><p>那么为什么会产生这两种现象？</p><p>当流入市场的货币总量变多，货物的供给没有变或者降低时则会造成通货膨胀。</p><p>当流入货币的市场的总量变少，货物的供给没有变或者便多则会造成通货紧缩。</p><p>这是两种完全无法避免的经济现象，但是在经济学上一般认为微量的通货膨胀是可以容忍的——因为这可以让一些价格，比如薪资和一些难以改变的物价可以重新定价。而通货紧缩则没有类似的功能，持续的通货紧缩将会造成生产端的破产以及经济衰退。</p><p>因此我们暂时认为，我们在设计整个经济系统需要保持整个经济系统呈现出微量通货膨胀的状态。</p><h3 id="基础货币">基础货币</h3><p>基础货币(<span class="math inline">\(Base\ Currency\)</span>，后文称之为 <span class="math inline">\(B\)</span> 货币)也称之为高能货币，这种货币投入到市场可以成倍扩增货币——举个例子，假如 <span class="math inline">\(A\)</span> 货币与基础货币的价值比值为 100:1，那么向市场内投入 1 基础货币相当于增加了 100 枚 <span class="math inline">\(A\)</span> 货币。</p><p>这种货币一般不直接使用，而是替换为流通货币(<span class="math inline">\(Currency\ In\ Circulation\)</span>)。</p><p>我们现在已经明白了基础货币 <span class="math inline">\(B\)</span> 和流通货币 <span class="math inline">\(A\)</span> 的关系实际上等于 <span class="math inline">\(A = nB\)</span> , <span class="math inline">\(n\)</span> 为货币倍率。</p><p>那么基础货币总量怎么计算？基础货币总量可以用一个非常简单但是可以变得非常复杂的式子来表示。</p><p><span class="math display">\[中央银行资产A1 + 中央银行负债A2 \approx 基础货币总量\]</span></p><p>由此我们可以大致估算基础货币到底有多少。对于一个简单的经济系统而言，我们就单纯认为服务器内基础货币总量计算方法为如下</p><p><span class="math display">\[玩家总资产A1 \approx 基础货币总量\]</span></p><h3 id="流通货币">流通货币</h3><p>流通货币( <span class="math inline">\(Currency\ In\ Circulation\)</span> )为最终投放到市场里的货币，与基础货币之间存有一定的比值。</p><p>我们可以用下面这样的示意图来表达基础货币和流通货币的关系</p><pre><code class=" mermaid">graph基础货币-- x1 --&gt;美元基础货币-- x8 --&gt;人民币基础货币-- x146 --&gt;日元</code></pre><p>考虑到 Vanilla Minecraft 的系统，就算是使用 Plug-in Vanilla Minecraft (eg. Spigot) 也大多数使用一种流通货币，那么我们现在就简单的认为流通货币和基础货币比例为 1:1</p><h3 id="微量的通货膨胀">微量的通货膨胀</h3><p>我们前面提到了，我们先假设每天的市场需求是不变的，那我们可以控制投放到市场中的货币，投放到市场中的货币多了我们的通货膨胀目标就实现了。</p><p>当然，前提是我们需要假设每天的市场需求是固定的，增加玩家的购买力，那玩家就有更多的钱去购买物品，供应商自然会给物品涨价，实现微量的通货膨胀。</p><p>那我们怎么实现投放到市场中的货币？答案是：每天上线就给玩家发钱。</p><p>非常简单粗暴的方法，那还有没有其他的？有，银行利率就是宏观调控通货膨胀的一部分。</p><p>但是这种方法需要额外设计银行系统，太复杂了我们就不探讨了吧 XD（目移</p><p>我们就简单的认为每天给玩家发钱就是控制通货膨胀的一部分就好了。</p><h3 id="税收">税收</h3><p>税收也是经济活动中重要的组成部分，税收可以有效抑制<em>需求拉动型的通货膨胀</em><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MBA 智库: 需求拉升型通货膨胀](https://wiki.mbalib.com/wiki/%E9%9C%80%E6%B1%82%E6%8B%89%E5%8A%A8%E5%9E%8B%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80)">[3]</span></a></sup>。</p><p>我们在这里探讨一下所得税，让后文的逻辑更加通顺，提供一种抑制通货膨胀的思路。</p><h4 id="需求拉动型的通货膨胀">需求拉动型的通货膨胀</h4><p>先解释一下什么叫做<em>需求拉动型的通货膨胀</em>。</p><p>假设全部的玩家都在开荒初期，那么势必会产生一种情况：物品全部价格起飞，因为这个时候需求极大，售卖方可以狠狠地捞一笔，最终导致了需求拉动型的通货膨胀。</p><p>然后？然后因为太贵了，没人买，需求回落，价格骤降，变成没人卖，玩家有钱花不出去，产生通货紧缩。</p><p>这种一种很自然的经济周期，但是有些逆周期的经济行为，不过我们不探讨。</p><h4 id="如何应对">如何应对</h4><p>那就是宏观调控，有两种方案。</p><p>方案 1: 向市场中投放足够多的平价货物，满足购买方的实际需求</p><p>方案 2: 对购买方征收所得税，降低购买方的意愿，进而延缓通货膨胀的速度。</p><p>不过我们需要知道的是，第二种方案实际上并不会解决通货膨胀的问题，它可以让通货膨胀变得足够缓慢，形成菲利普斯曲线<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[MBA 智库: 菲利普斯曲线](https://wiki.mbalib.com/wiki/%E8%8F%B2%E5%88%A9%E6%99%AE%E6%96%AF%E6%9B%B2%E7%BA%BF)">[4]</span></a></sup>。</p><p>在本节内容我们讨论第二种方案，现实生活中往往是两种方案混用。</p><p>我们在购买物品的时候会产生所得税，纳税人是购买方，当对于这种物品税收过重时我们对这种物品的需求就会降低，因为实际上太贵了，商家也没赚到多少钱。</p><p>那这样看，不是他会通货紧缩吗？说好的通货膨胀呢？因为往往我们不会设置太高的税收，我们的最终目的是防止这种物品导致过快的通货膨胀。</p><p>我想买的东西是必需品，即使是它税很重，我也会去购买。</p><p>商家在短时间内会意识到市场的需求上升，因为很多玩家都需要，所以会涨价（增加供给）。</p><p>但是买方因为税收不会多买，会以后再买（需求降低）。</p><p>在这时就产生了通货膨胀，但是与此同时玩家的需求是被压制的。</p><p>商家在买方需求降低后慢慢减少上架的货物（减少供给）。</p><p>在渡过高需求的阶段后可以适当降低税收，玩家的需求会上升（需求上升）。</p><p>由此完成了整个经济周期，并且结果税收的调控后通货膨胀显得比较平稳不至于货价高速膨胀。</p><p>但是这种通货膨胀是<strong>健康</strong>的，只要它经过<strong>调控</strong>。</p><p>从长远来看，市场是有自我调控能力的，即使是不设置税收他也能自己调节。</p><p>但是从长远看，到底多长远？所以我们<strong>基于市场需要一定的干预的前提</strong>认为税收是有必要的。</p><h2 id="动手设计">动手设计</h2><p>我们简单地探讨了一下一个经济系统需要什么东西，那么我们开始收集一个经济系统需要什么部分吧！</p><p>由以上的探讨我们可以以一个极其原始的观点开始构建一个比较简单的经济系统。</p><ul><li>基础货币 <span class="math inline">\(Base\ Currency\)</span></li><li>流通货币 <span class="math inline">\(Currency\ In\ Circulation\)</span></li><li>基础货币与流通货币的换算关系</li><li>基础货币的具体表现形式</li><li>玩家间货币的流转</li><li>官方市场，用于提供官方控制物价的市场</li><li>物品的定价规则</li><li>税收，以及税收后的去向</li><li>通货膨胀的形式</li></ul><h3 id="货币系统">货币系统</h3><p>作为一个货币系统，首先我们需要一个基础货币，我们叫他 <span class="math inline">\(B\)</span> 货币吧！</p><p><span class="math inline">\(B\)</span> 货币作为世界通用货币，但是不在任何经济体系中流通，因为它不是<strong>流通货币</strong>。</p><p>为了我们设计方便，我们就额外设计一个 <span class="math inline">\(A\)</span> 货币，其和 <span class="math inline">\(B\)</span> 货币兑换的比值为 <span class="math inline">\(1:1\)</span></p><p>我们需要一种物品来描述 <span class="math inline">\(B\)</span> 货币，那么挑选一个合适的物品吧！这种物品没有太多用途，玩家甚至不想要。那就...暂定成铜锭吧，我们让这种物品从世界上彻底消失，无法获取也不参与任何合成表。</p><p>它和 <span class="math inline">\(B\)</span> 货币比值为 <span class="math inline">\(1:100\)</span>，也就是 1 个铜锭实际上等于 100 个 <span class="math inline">\(B\)</span> 货币</p><p>用以下示意图表示</p><pre><code class=" mermaid">graph LR铜锭--- |x100| B货币B货币--- |x1| A货币B货币--- |x10| C货币B货币--- |x50| D货币</code></pre><h3 id="市场">市场</h3><p>涉及到市场，必定分为由管理员设立的市场以及玩家互相之间的市场，在这里我们只讨论管理员设立的市场，玩家之间设立的市场我们称之为"黑市"，管理员设立的市场称之为"白市"</p><p>白市需要确定哪些物品可以在此出售，因为市场需要一定的管控，并且需要设置最低的物价。</p><p>在最低的物价之上允许玩家自由定价，并且需要管理员对物价进行管理，防止玩家对物价进行恶意炒作，产生垄断现象。</p><p>对于黑市，也就是玩家之间的自由市场，白市应当与黑市正面竞争，在可以的情况下需要和黑市拼比同等物品的价格，并且白市应当尽可能的扩充自己可以出售的物品。</p><p>于是我们面对新的问题：物品定价</p><h4 id="物品定价">物品定价</h4><p>对于物品定价，需要遵守一定的规律：</p><ul><li>若是稀有物品：考虑从稀有程度下手，不可再生并且无功能的的稀有物品应当禁止出售，并且尽可能压低该物品的价值</li><li>若是资源物品：考虑从丰度下手，比如矿石等。再考虑获取的时间成本，这种物品应当鼓励玩家出售</li><li>若是功能物品：考虑从获取难易度下手，比如附魔书。该物品定价需要一定的技巧，需要考虑获取难度以及物品的功能性</li></ul><h4 id="物品定价资源物品">物品定价：资源物品</h4><p>我们以矿石为例，一个矿石产物的定价可以以以下的函数为计算方式</p><p><span class="math display">\[价格P0=基础价格P1+劳动成本B*\sqrt{矿石丰度A}*资源系数X \\\]</span></p><p><span class="math display">\[矿石丰度A=区块生成期望Y\]</span></p><p><span class="math display">\[劳动成本B=平均获取时间T\]</span></p><p>资源系数为社区需求程度，我们假设这是个固定值，实际上这个系数可以非常地动态。</p><p>考虑钻石的情况，我们令物品的基础售价为<span class="math inline">\(P1=100\)</span>，<span class="math inline">\(B=T=600s*1\)</span>，<span class="math inline">\(A=3\)</span>，<span class="math inline">\(X=100\)</span></p><p>那我们的式子就变成了这样：</p><p><span class="math display">\[P0=100+600*\sqrt{3}*100 \approx 100+600*1*100=60100\]</span></p><p>一个钻石的价格就是 <span class="math inline">\(P0=60100\)</span> 了。</p><p>当然，这个式子非常粗糙，一定要重新设计，一定要重新设计，一定要重新设计，重要的话要说三次。</p><h3 id="税收设计">税收设计</h3><p>对于服务器而言，不想要考虑税收收上来的税用于做什么——哪怕是退税都不需要考虑。</p><p>所以我们可以简单的认为税收就是为了有效抑制需求拉动型通货膨胀的手段，并且用于回收市场的金币。</p><p>税收是一种有效抑制需求拉动型通货膨胀的方案，但是这部分的操作是需要动态的——当需要通过税收抑制需求拉动型通货膨胀时，税收过低，导致税收没有起到抑制通货膨胀的作用；当不需要税收抑制需求拉动型通货膨胀时，过重的税收会导致通货紧缩，过大地抑制市场需求。</p><p>我们简单地认为价格为 <span class="math inline">\(ST\)</span> 的物品购买时产生的所得税税率为 <span class="math inline">\(TA\%\)</span>，那么玩家实际上需要使用 <span class="math inline">\(ST*(1+TA)\%\)</span> 流通货币来购买，那么税收则为 <span class="math inline">\(T=ST*TA\%\)</span>，本次交易中从市场里消失的货币为 <span class="math inline">\(T\)</span>。</p><p>当日从市场里消失的货币则为</p><p><span class="math display">\[D=\sum_{i=1}^{n}T_{i}，n=当日市场交易次数\]</span></p><p>但是，对于税收我们依然是需要去统计的——因为税收收上来的税不再有用途，但是会实实在在地减少市场中的金币，会导致通货紧缩，所以若需要保证经济系统微量通货膨胀，这部分减少的金币需要以另外一种方式还给玩家。</p><h3 id="通货膨胀">通货膨胀</h3><p>我们假设需要保证经济是微量通膨的，那么我们需要考虑到一个问题：不再活跃的玩家是否可以认为是市场流通货币的持有者？</p><p>因为如果一个玩家不再活跃了，相当于这个玩家以及这个玩家所持有的货币彻底从市场里消失了，这部分货币属于暂时蒸发状态，所以我们暂时认为这部分的玩家的货币已经不存在了，或者我们认为这部分玩家的货币自从某天突然从市场里<strong>消失</strong>了即可。</p><p>我们简单的认为我们地目的就是让市场里的钱以一定的比例变多，那么我们可以以以下的式子来进行计算。</p><p><span class="math display">\[I=\frac{当日投入到市场中的货币B-过去一天市场里减少的流通货币A}{活跃货币总量C}\]</span></p><p>其中 <span class="math inline">\(A\)</span> 包含了过去一天的总税收 <span class="math inline">\(T\)</span>，过去一天被判定为不活跃玩家的财产 <span class="math inline">\(F\)</span>，那么可以得到如下式子</p><p><span class="math display">\[A=过去一天的总税收T+过去一天被判定为不活跃玩家的财产F\]</span></p><p>那我们如何将 <span class="math inline">\(B\)</span> 投入到市场当中？答案是每日上线附送的金币。</p><p>考虑到存在玩家赎回财产，那么 <span class="math inline">\(A\)</span> 是有可能为负的，而我们要计算的 <span class="math inline">\(B\)</span> 会因此变成负数，反而从玩家包里扣钱，这显然是不可能的。</p><p>因此若 <span class="math inline">\(B\)</span> 小于 0 时，服务器不会发放当日的金币福利（或者仅仅保留基础福利）。</p><p>我们可以导出如下计算式子。</p><p><span class="math display">\[B=I*C+(T+F)\]</span></p><p>所以我们每日发给玩家的货币就变成了如下计算式。</p><p><span class="math display">\[PB=\frac{B}{n}，n=活跃玩家总数\]</span></p><p>总量为<span class="math inline">\(PB\)</span>的货币会在玩家上线时发给玩家。但我们不需要保证每天的任务都是达标的，如果我们需要保证每天的任务达标的话我们可以考虑直接加算到玩家的钱包里。</p><h2 id="收尾">收尾</h2><p>其实给 Vanilla Minecraft 设计经济系统总是一个不合适的想法，因为 Vanilla Minecraft 的资源实际上是无限的，几乎所有生产资料都是拿在玩家手上的，某种意义上是共产社会。</p><p>但是总是有很多玩家和维护人员乐此不疲地给他设计新的内容，即使是 Mojang 开始教玩家玩游戏，玩家也不会放弃实现他们的想法，或许这就是这个游戏即使是现在也依然生机勃勃的原因吧。</p><p>用一句很真实的话为我们的原始经济系统设计探讨之路画上句号吧。</p><blockquote><p>从长远来看，我们都死了。</p><footer><strong>John Maynard Keynes，约翰·梅纳德·凯恩斯</strong></footer></blockquote><p>不去做，怎么会知道他到底怎样？从长远来看，那又如何？</p><h2 id="叠甲">叠甲</h2><ul><li>笔者不是经济方面专业的学生，对于这部分的设计和想法是基于自己长期的经验积累以及阅读获取导出的。</li><li>如有不恰当的地方，还请斧正。</li></ul><!-- 引用 --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E7%B3%BB%E7%BB%9F">MBA 智库：经济系统</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这部分是微观经济元素，定义并不是很明确，只能暂时这么定义，并且这么定义是符合上下文的关系的。<a href="#fnref:1" rev="footnote"> ↩︎</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这里是宏观的经济元素，定义较为明确，但不唯一。<a href="#fnref:2" rev="footnote"> ↩︎</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.mbalib.com/wiki/%E9%9C%80%E6%B1%82%E6%8B%89%E5%8A%A8%E5%9E%8B%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">MBA 智库: 需求拉升型通货膨胀</a><a href="#fnref:3" rev="footnote"> ↩︎</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.mbalib.com/wiki/%E8%8F%B2%E5%88%A9%E6%99%AE%E6%96%AF%E6%9B%B2%E7%BA%BF">MBA 智库: 菲利普斯曲线</a><a href="#fnref:4" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>学习</tag>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyRemapper笔记</title>
    <link href="/2023/06/23/TinyRemapper%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/23/TinyRemapper%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>记录一下探索 TinyRemapper 和 FabricMC 构建流程</p><span id="more"></span><h2 id="tinyremapper-是什么">TinyRemapper 是什么</h2><p>这是一个隶属于 FabricMC 的构建流水线(<em>Build Pipelines</em>)的一部分，TinyRemapper 可以对 JAR 应用 <code>Tiny</code> 映射格式(<em>Remapping format</em>)。</p><div class="note note-success">            <p>映射，顾名思义就是把一个东西等价称为另外一个东西。</p><p>关于为什么会有这个东西，是因为开发商对 JAR 构建结果应用保护措施而产生，在本文不再赘述。</p>          </div><p>在应用完毕后，我就可以让名为 <code>A</code> 的函数名可以称之为 <code>getBlock</code> ，<strong>这对反混淆来讲非常重要，而这是反混淆的最基础能力</strong>。</p><h2 id="fabricmc-build-pipelinesfabricmc-构建流水线">FabricMC Build Pipelines：FabricMC 构建流水线</h2><p>在这一部分需要单独提出，这对于理解 TinyRemapper 的功能与作用非常重要。</p><pre><code class=" mermaid">graphloom(FabricLoom Build Logic)--构建--&gt;YarnMappedBytecode--TinyRemapper应用Yarn到中间名映射--&gt;IntermediaryMappedBytecode--TinyRemapper应用中间名到原始名映射--&gt;TargetBytecodesrc(模组源代码)--&gt;loomlib(YarnMappedMinecraft)--&gt;srcmc(Minecraft)--TinyRemapper应用原始名到中间名的映射--&gt;IntermediaryMappedMinecraft--TinyRemapper应用中间名到Yarn的映射--&gt;lib</code></pre><p>可以看出 TinyRemapper 负责的部分是把我们可读的代码重新映射成 JVM 虚拟机内执行需要的代码，或者帮我们把我们读不懂的代码重新映射成我们能读懂的代码。</p><p>在 JVM 程序执行机制里，我们运行的 Minecraft 程序是使用原始名，这对我们来讲是几乎不可读的。Yarn 提供了一套标准的、自由的名称，让我们的体验更加顺畅。如果我们在模组里面调用了 Minecraft 的某个函数，对于 JVM 而言是 <code>INVOKE*</code> 命令<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="包含 `INVOKEVIRTUAL`，`INVOKESPECIAL`，`INVOKESTATIC`，`INVOKEINTERFACE`，`INVOKEDYNAMIC`">[0]</span></a></sup> ，而这些命令的参数其实是 Minecraft 的原始名，比如 <code>aabb/26390</code> 。</p><p>但是我们其实不会这样写，我们写的通常是类似 <code>world.getBlock</code> 这样的代码。</p><p>在完成编译后，JVM 居然能应用正确的参数。</p><p>这其中发生了什么？</p><h3 id="反混淆">反混淆</h3><p>顾名思义，反混淆就是把混沌的东西变成我们可以读懂的玩意儿</p><p>首先我们需要清楚，Mojang 在最早是不给我们提供资料的，我们只有猜。并且不是因为 Minecraft 才出现的反混淆，这是自 JVM 与 Java 诞生之初推广成功后便产生的东西。</p><p>在我们猜到这个非常混沌的方法名 <code>26390</code> 的大概作用后，我们就可以给他一个有意义的名字，并且记录下来。</p><p>记录下来后，映射便诞生了。</p><h3 id="重映射重混淆">重映射（重混淆）</h3><p>我们使用一些手段对字节码应用映射，这样我们就能顺利的写出 <code>world.getBlock</code> 这样的代码了，而不需要和 <code>abjxc1.asobb</code> 这样诡异的东西作斗争。</p><p>可是问题来了，我们前面说了，实际上这样做字节码指令的参数是不对的，是 <code>world/getBlock</code> ，JVM 是找不到 ClassPath 的——因为根本没有这个东西。</p><p>我们需要使用一个工具，用一种手段，和反混淆相反的手段，来纠正这些 ClassPath 和字节码指令参数，不如就叫做...<strong>重映射</strong>吧！</p><p>在经过这个流程后，我们的代码编译出来的模组终于可以被 JVM 正常加载，以及正常加载调用 Minecraft 的函数了。</p><h3 id="中间名的诞生">中间名的诞生</h3><p>在经过长期的经验中我们发现了一个大问题——他奶奶的，Mojang 一张混淆表给他妈的用的天荒地老<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="起码从 1.7.10 到现在没有变过">[1]</span></a></sup>。</p><p>而且两个版本之间经常一堆代码不变，那我是不是只用在意两个版本之间的新增和减少？</p><p>不对啊，聪明点的人肯定能想到这个玩意儿，而且早就在搞了。</p><p>确实是这样，并且 Yarn，MCP，Spigot 更新流程都是这样的。</p><p>问题是假如，我的意思是假如，假如我 Minecraft 的两个版本更新过快，你没时间反应，阁下又当如何应对？</p><p>又比如说，我需要编译前扫描整个 Minecraft 的字节码提取有用的信息，那编译可真的太慢了。</p><p>那我干脆直接早点提出来，要用的时候直接加载，快不快？非常快。</p><p>我假如说，我想 Mojmap 和 Yarn 混用，阁下又当如何应对？</p><p>没错，我会做一个转接层，而 Minecraft 反混淆后的各种方法名，字段名，类名，就叫做<strong>中间名</strong>！</p><p>然后我一视同仁，我把依赖的模组，全部用中间名转换成我想用的映射名，非常完美。</p><h2 id="理解-tiny-格式">理解 Tiny 格式</h2><p>TinyRemapper 有它们自己的格式，这是这个笔记的重点</p><p>这篇笔记以 1.19.4 的 <a href="https://raw.githubusercontent.com/FabricMC/intermediary/master/mappings/1.19.4.tiny">tiny 文件</a>为例</p><p>第一行可以直接忽略，我们称之为 <code>TinyRemapper Metadata</code></p><p>从第二行开始，就全是我们的主角了。</p><p>从分析角度来看，整个 tiny 文件格式应该以行为分析单位，因此我们也会以行作为例子来分析。</p><p>同时我也会用 Rust 代码来表达应有的储存结构，使用 TinyRemapper 的解析逻辑作为分析依据。</p><h3 id="class">CLASS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tiny">CLASS    a    net/minecraft/class_4581<br>│───│   │─│   │──────────────────────│<br>  │      │             │<br>  │      │             │<br>  │      │             │<br>  │      │             └──────── 完全限定名<br>  │      └────────────────────── 归属文件（混淆名）<br>  └───────────────────────────── `CLASS` 类型描述<br></code></pre></td></tr></table></figure><p>对于这行的解析，我会把他用 Rust 代码表述为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Class</span> &#123;<br>    obf_name: <span class="hljs-type">String</span>,<br>    intermediary_name: <span class="hljs-type">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的 Java 代码为<a href="https://github.com/FabricMC/tiny-remapper/blob/fa0c4e72f6ce434e91b0adbcc82a9b021eed6cc3/src/main/java/net/fabricmc/tinyremapper/TinyUtils.java#L234-L237">这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;CLASS&quot;</span>.equals(type)) &#123;<br>    out.acceptClass(splitLine[<span class="hljs-number">1</span> + fromIndex], splitLine[<span class="hljs-number">1</span> + toIndex]);<br>    <span class="hljs-keyword">if</span> (obfFrom != <span class="hljs-literal">null</span> &amp;&amp; !splitLine[<span class="hljs-number">1</span> + fromIndex].isEmpty()) obfFrom.put(splitLine[<span class="hljs-number">1</span>], splitLine[<span class="hljs-number">1</span> + fromIndex]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="field">FIELD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tiny">FIELD    b    F    a    field_21633<br>│───│   │─│  │─│  │─│   │─────────│<br>  │      │    │    │         │<br>  │      │    │    │         └── 中间名<br>  │      │    │    └──────────── 混淆名<br>  │      │    └───────────────── 类型方法描述符<br>  │      └────────────────────── 归属文件<br>  └───────────────────────────── `FIELD` 类型描述<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Field</span> &#123;<br>    class: <span class="hljs-type">String</span>,<br>    type_desc: <span class="hljs-type">String</span>,<br>    obf_name: <span class="hljs-type">String</span>,<br>    intermediary_name: <span class="hljs-type">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="method">METHOD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tiny">METHOD    a    (F)Lorg/joml/Quaternionf;    a    method_46349<br>│────│   │─│   │───────────────────────│   │─│   │──────────│<br>  │       │                 │               │          │<br>  │       │                 │               │          └ 中间名<br>  │       │                 │               └─────────── 混淆名<br>  │       │                 └─────────────────────────── 返回值方法描述符<br>  │       └───────────────────────────────────────────── 归属文件<br>  └───────────────────────────────────────────────────── `METHOD` 类型描述<br></code></pre></td></tr></table></figure><p>METHOD 和 FIELD 的处理逻辑是是一样的，所以直接看 <code>CLASS</code> 描述类型的代码就行。</p><p>对应的 Rust 代码为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Method</span> &#123;<br>    class: <span class="hljs-type">String</span>,<br>    return_desc: <span class="hljs-type">String</span>,<br>    obf_name: <span class="hljs-type">String</span>,<br>    intermediary_name: <span class="hljs-type">String</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>除此之外，tiny 还有注释，是以 <code>#</code> 开头的。</p><p>以上代码的描述与处理我放在了 <a href="https://gist.github.com/Krysztal112233/6e1c9d90f193e44ce725bc39c914426c">Gist</a> 上，需要可以自行参考。</p><!-- 引用 --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">包含 <code>INVOKEVIRTUAL</code>，<code>INVOKESPECIAL</code>，<code>INVOKESTATIC</code>，<code>INVOKEINTERFACE</code>，<code>INVOKEDYNAMIC</code><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">起码从 1.7.10 到现在没有变过<a href="#fnref:1" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>学习</tag>
      
      <tag>Minecraft</tag>
      
      <tag>FabricMC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MicroOS：进阶</title>
    <link href="/2023/06/12/MicroOS%EF%BC%9A%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/06/12/MicroOS%EF%BC%9A%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>知道了 MicroOS 的基本理念，那么就该用这些基本理念构建服务了。</p><span id="more"></span><h2 id="运行服务">运行服务</h2><p>对于服务的运行，在 MicroOS 上更倾向使用容器方案，但是如果你要使用 <code>Systemd</code> 也是可以的，毕竟 MicroOS 只是保证了系统的事务性，只要有办法持久化数据即可.</p><p>对于这一点，你需要一些容器编排软件，比如说:</p><ul><li>K8S</li><li>Docker Compose</li><li>Podman</li></ul><p>当然，就算是用这些东西，也要注意整个系统是事务化的，需要用新的快照来保存。</p><h2 id="数据持久化">数据持久化</h2><p>对于数据持久化，这是一个重头戏，从各种意义上来讲使用了 MicroOS 的服务器并不适合持久化储存数据，而你需要为你的 MicroOS 服务器配备一些能帮助他储存的东西，比如说 NFS.</p><h3 id="nfs">NFS</h3><p>这是我最推荐的方式，只要配置好 MicroOS 的 NFS 自动挂载，保证 NFS 主机不会宕机，那么基本上可以保证万全.</p><p>记住，你得好好配置 NFS 的权限和设置，不然的话越权访问了你的 MicroOS 就会互相感染._即使它们会自动恢复，但是数据无价_</p><h3 id="ftp">FTP</h3><p>非常不推荐，有这个想法可以直接跳过了.</p><h2 id="系统升级">系统升级</h2><p>忘记我重复提起的所谓事务性了吗？也就是说升级系统是一件事务，你需要在新的快照层上进行更改。</p><p>意思是实际上需要以下步骤：</p><ul><li>创建新的事务</li><li>执行软件包更新</li><li>保存事务</li><li>重启，验证是否正常工作（HealthCheck）</li></ul><h2 id="结语">结语</h2><p>这只是个非常非常细碎的笔记，其实记录到这里已经差不多了。关于系统的缩放性这不是我能讲的，权当是我自己的笔记罢了</p>]]></content>
    
    
    <categories>
      
      <category>捣鼓</category>
      
      <category>系统</category>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
      <tag>MicroOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MicroOS：起步</title>
    <link href="/2023/05/15/MicroOS%EF%BC%9A%E8%B5%B7%E6%AD%A5/"/>
    <url>/2023/05/15/MicroOS%EF%BC%9A%E8%B5%B7%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>MicroOS 是 SUSE 旗下一款很新的系统，面向原子化与自动化维护。</p><p>那么该从何体会它的好？它是为什么而诞生的？</p><span id="more"></span><h2 id="特性">特性</h2><ul><li>作为一款面向云端高效稳定的服务器操作系统，秉持容器第一的原则：程序服务均在容器上运行</li><li>为了保证系统运行的稳定性，操作系统的根文件为只读</li><li>有健康检查机制 <a href="https://github.com/kubic-project/health-checker">Health Checker</a> 确认当前运行的操作系统工作正确——如果工作不正确，则自动切换到上一个快照保证系统正确。而当添加了其他的需要验证正确性的服务，只需要给健康检查机制编写新的插件即可</li><li>采用事务性更新机制 <a href="https://kubic.opensuse.org/documentation/transactional-update-guide/transactional-update.html">Transactional Updates</a> 更新系统，而不影响当前运行中的系统</li></ul><h2 id="步入-microos-的第一步">步入 MicroOS 的第一步</h2><p>面对这样一个理念几乎全新的系统，需要重新了解一些特性才能正确的搞懂它</p><h3 id="重新整理理念">重新整理理念</h3><h4 id="系统的不可变性">系统的不可变性</h4><p>在普通的操作系统，比如最基本的 Debian 与 Ubuntu 与 Arch，更新操作系统往往会导致<strong>当前</strong>的操作系统的「文件系统」发生更改</p><p>而对于 MicroOS 来讲，更新系统并不会更新到当前正在运行的系统之上，而是在当前运行的系统之上建立一层新的「文件系统」，在下一次启动操作系统的时候才会应用最新的「文件系统」</p><h4 id="软件与服务">软件与服务</h4><p>对于 MicroOS，软件更倾向于<strong>系统层面</strong>的工具，而服务从由 Systemd 接管的部分更改为由容器运行时管理的<strong>容器</strong></p><p>这对于普通的发行版是由一定的区别的。普通的发行版往往是把它们混杂在一起，软件是服务，服务也是软件</p><h4 id="可伸缩性">可伸缩性</h4><p>对于 MicroOS，其保证了尽可能快的启动，因此相比与普通的发行版，MicroOS 更能适合需要伸缩的大型系统</p><h4 id="批量部署">批量部署</h4><p>MicroOS 提供了一个批量部署工具，能让系统管理员可以快速的大规模部署 MicroOS</p><h3 id="系统维护">系统维护</h3><p>对于 MicroOS 的系统，其使用了 openSUSE Leap 或者 openSUSE Tuwbleweed，也就是其基础系统的系统套件取决于你选择了基于哪个发行版的 MicroOS（基本上都是 Tuwbleweed）</p><h4 id="软件包">软件包</h4><p>如果你需要在基础系统上进行操作，你需要使用 <code>transactional-update pkg</code> 命令取代 openSUSE 的 <code>zypper</code> 命令</p><p>在对系统完成软件更新更改之后，需要使用 reboot 更换到最新的系统——这一点与 NixOS 极其类似，但是 MicroOS 采用的是 Btrfs 快照保证的原子化，而 NixOS 选择的是挂载不同的 nix store 来实现</p><h4 id="修改配置">修改配置</h4><p>如果你要修改系统的配置，类似 <code>/etc</code> 这些放配置文件的地方，你需要使用 <code>transactional-update shell</code> 进入一个新的可变快照里面——这个快照会在下一次重启时应用，或者使用 <code>transactional-update apply</code> 提前应用（不推荐）</p><h4 id="自维护">自维护</h4><p>什么叫做自维护？自动维护指的是不需要人工干预，系统即可实现自己对自己进行维护——比如说系统没有正常启动，那么系统将会进入自维护模式尝试让自己启动成功</p><p>听起来很神奇，但是原理其实很简单</p><p>还记得 MicroOS 有一个健康检查的工具套件吗？它预置了基础系统需要检查用的脚本，如果这些脚本执行后返回的值都是 0，那么证明系统启动成功；反之如果有一个返回了其他值，那么证明系统没有启动成功，MicroOS 会进行自回滚：回滚到以前的快照，直到有一个快照健康检查正常</p>]]></content>
    
    
    <categories>
      
      <category>捣鼓</category>
      
      <category>系统</category>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
      <tag>MicroOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swapfile 指北</title>
    <link href="/2023/01/29/Swapfile%20%E6%8C%87%E5%8C%97/"/>
    <url>/2023/01/29/Swapfile%20%E6%8C%87%E5%8C%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>swapfile 和 swap 是同种东西，都是<strong>虚拟内存</strong>。不过各有优劣，需要按照自己的需求选择。</p><span id="more"></span><p>本文不提供创建 swapfile 和 swap 分区的教程，但是提供你可能会用到的文档链接</p><h2 id="概念">概念</h2><p>这个东西在 Windows 和 Linux 上的叫法其实不太一样，但是功能是一致的</p><ul><li>Windows 和 macOS 上可能叫做交换文件，虚拟内存</li><li>Linux 上一般只叫做 swap 或者交换内存</li></ul><p>下文全部叫做交换内存或者 swap</p><h2 id="使用分区还是使用文件">使用分区？还是使用文件？</h2><p>使用分区可以在你有一个十分高速的磁盘上将整个磁盘都规划为交换内存，在这种情况下优势是：没有文件系统的额外开销，内核是直接将硬盘作连续的内存空间使用的</p><p>但是有些时候你会需要更加灵活的操作，这个时候你需要使用一些文件系统上的开销，创建一个 swap 文件即可</p><p>下表可以一眼看出优势和劣势</p><table><thead><tr class="header"><th style="text-align: center;">swap 方案</th><th style="text-align: center;">优势</th><th style="text-align: center;">劣势</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">分区</td><td style="text-align: center;">性能最好</td><td style="text-align: center;">不灵活</td></tr><tr class="even"><td style="text-align: center;">文件</td><td style="text-align: center;">灵活</td><td style="text-align: center;">性能稍差</td></tr></tbody></table><h3 id="分区方案">分区方案</h3><p>常见于自己电脑安装 Linux 发行版时发行版默认创建的 2GB 大小 swap 分区</p><p>这种 swap 方案往往是发行版自行管理的<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Debian 论坛：swap 分区](https://forums.debian.net/viewtopic.php?t=146429)">[0]</span></a></sup>，并且推荐至少有 2GB 大小的 swap 分区</p><p>不过也可以自己来挂载额外的一块 swap 分区，这种分区一般推荐是在单独的一块高速硬盘上</p><h3 id="文件方案">文件方案</h3><p>这种方案十分灵活，比如你可以在根目录下创建一个 <code>.swapfile</code>，并且把它使用 <code>mkswap</code> 命令格式化成为一个 <code>swapfile</code></p><p>接下来就出现了两个分支了<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[DebianWiki](https://wiki.debian.org/Swap)">[3]</span></a></sup></p><ol type="1"><li>通过 <code>swapon</code><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[swapon 命令的 man 手册](https://linux.die.net/man/8/swapon)">[1]</span></a></sup> 命令临时挂载起来作为 swap 使用</li><li>写入到 <code>/etc/fstab</code> 使得系统可以在开机的时候自动挂载成为 swap</li></ol><h3 id="备选">备选</h3><p>什么，备选方案？有！</p><p>你想一下，这个世界上存在一些原地压缩与解压的算法比如 <code>lzo</code> 和 <code>lz4</code>，他们不消耗内存并且可以压缩数据</p><p>内存也是数据，为什么不能压缩？</p><p>那我使用这些压缩算法压缩内存不就变相扩大了内存？好聪明！</p><p>但是这种操作的代价就是一旦进入 swap 了会消耗更多的 CPU 资源，这种技术就叫做 <code>zram</code></p><p>很多发行版提供了对应的工具比如 <code>zram-tools</code></p><!-- reference --><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://forums.debian.net/viewtopic.php?t=146429">Debian 论坛：swap 分区</a><a href="#fnref:0" rev="footnote"> ↩︎</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://linux.die.net/man/8/swapon">swapon 命令的 man 手册</a><a href="#fnref:1" rev="footnote"> ↩︎</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.debian.org/Swap">DebianWiki</a><a href="#fnref:3" rev="footnote"> ↩︎</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://wiki.debian.org/ZRam">DebianWiki: Zram</a><a href="#fnref:4" rev="footnote"> ↩︎</a></span></li></ol></div></div>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPG物理密钥的安装与密钥的迁移</title>
    <link href="/2022/06/22/GPG%E7%89%A9%E7%90%86%E5%AF%86%E9%92%A5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%BF%81%E7%A7%BB/"/>
    <url>/2022/06/22/GPG%E7%89%A9%E7%90%86%E5%AF%86%E9%92%A5%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%AF%86%E9%92%A5%E7%9A%84%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>自从买到了心心念念的偶尔才有货的 CanoKey 后就想着怎么发挥我能用到的它的所有功能，配置好一些网站的 <code>2FA</code> 后就咸鱼了。</p><p>然后我发现他可以保存 OpenPGP 密钥，作为 GPG 的物理密钥。</p><span id="more"></span><h2 id="前置要求">前置要求</h2><ul><li>需要一个 OpenPGP 支持的 Smartcard，比如 CanoKey，Yubikey。由于 Yubikey 价格过高，我选择的是开源平替 <a href="https://canokeys.org/">CanoKey</a></li><li>提前安装好 Gpg4Win 之类的 OpenPGP 工具。当然你也可以使用 Git 内自带的 GPG</li><li>能识别你的硬件的电脑或者硬件（</li></ul><h2 id="思路">思路</h2><p>我们需要做以下事情：</p><ul><li>初始化硬件</li><li>生成子密钥</li><li>备份主密钥</li></ul><h3 id="初始化-smartcard后文称之为物理密钥">初始化 Smartcard（后文称之为物理密钥）</h3><p>经过如下步骤处理可以获得初始化完毕的物理密钥，当然敏感信息也会脱敏。</p><h4 id="获取是否能正确识别到物理密钥">获取是否能正确识别到物理密钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gpg --card-edit<br><br>Reader ...........: canokeys.org OpenPGP PIV OATH 0<br>Application ID ...: ******<br>Application <span class="hljs-built_in">type</span> .: OpenPGP<br>Version ..........: 3.4<br>Manufacturer .....: unknown<br>Serial number ....: ******<br>Name of cardholder: [not <span class="hljs-built_in">set</span>]<br>Language prefs ...: [not <span class="hljs-built_in">set</span>]<br>Salutation .......:<br>URL of public key : [not <span class="hljs-built_in">set</span>]<br>Login data .......: [not <span class="hljs-built_in">set</span>]<br>Signature PIN ....: forced<br>Key attributes ...: rsa2048 rsa2048 rsa2048<br>Max. PIN lengths .: 64 64 64<br>PIN retry counter : 3 3 3<br>Signature counter : 0<br>Signature key ....: [none]<br>Encryption key....: [none]<br>Authentication key: [none]<br>General key info..: [none]<br><br>gpg/card&gt;<br><br></code></pre></td></tr></table></figure><p>如果你的输出和我的差别不大，那么意味着你的物理密钥已经被系统识别到了。</p><h4 id="初始化你的物理密钥">初始化你的物理密钥</h4><p>这一步推荐阅读 <a href="https://wiki.debian.org/Smartcards/OpenPGP">Debian Wiki - Smartcards OpenPGP#Initialise the smartcard</a></p><p>简而言之，你需要设置你的物理密钥的</p><ul><li>用户名</li><li>语言</li><li>Reset Code</li><li>Admin PIN</li><li>PIN</li></ul><h3 id="生成主密钥">生成主密钥</h3><p>由此可知，你需要先生成主密钥。这一步推荐根据 <a href="https://keyring.debian.org/creating-key.html">Debian Wiki - Creating a new GPG key</a> 做。</p><p>当你完成了生成主密钥，那么你接下来需要生成子密钥，而主密钥必须要离开你的设备进行保存。</p><h3 id="生成子密钥">生成子密钥</h3><p>你需要生成三个子密钥，分别是认证(C)，签名(S)，加密(E)。</p><p>输入以下命令开始创建三个子密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gpg --edit-key --expert [Your Key ID]<br><br>******<br><br>gpg&gt; addkey<br>Key is protected.<br>...<br>&gt; 选 RSA (sign only)。<br><br>******<br><br>gpg&gt; addkey<br><br>&gt; 选RSA (encrypt only).<br><br>******<br><br>gpg&gt; addkey<br><br>&gt; 选RSA (<span class="hljs-built_in">set</span> your own capabilities)<br>&gt; 选中 S 和 E 去选掉他们，然后选中 A<br><br>******<br><br>gpg&gt; save<br></code></pre></td></tr></table></figure><p>子密钥生成后，我们需要做两件很重要的事情——生成吊销证书，搬家密钥到安全的地方。</p><h3 id="生成吊销证书">生成吊销证书</h3><p>当你的主密钥泄漏的时候，你需要吊销你的主密钥，这个时候吊销证书就会派上用场了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --output revoke.asc --gen-revoke &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>这个<strong>证书需要妥善保管</strong>，不然任何摸到他的人都能让你的密钥失效。</p><h3 id="备份你的所有密钥">备份你的所有密钥</h3><p>你的密钥应当全部拥有备份，备份或许可以打印出来，或许可以放到离线储存介质上。</p><p>总之备份应当足够的安全离线，要是你想可以让安保机构帮你保管。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --output privkey.sec --export-secret-key &lt;Your Key ID&gt;<br>gpg --armor --output subkeys.sec --export-secret-subkeys &lt;Your Key ID&gt;<br>gpg --armor --output pubkey.asc --<span class="hljs-built_in">export</span> &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>导出的私钥与公钥应当妥善保管，你的保存介质<strong>应当得到妥善保管</strong>，包括你的吊销证书。</p><p>也就是说你需要备份以下四个东西。保护好他们</p><ul><li>revoke.asc</li><li>privkey.sec</li><li>subkeys.sec</li><li>pubkey.asc （可以选择不备份他，因为他是公钥）</li></ul><h3 id="让主密钥离线">让主密钥离线</h3><p>在完成以上内容后，你应当命令你的主密钥离线。如果你有另外一个物理密钥的话（下文称之为第二物理密钥），你可以选择把你的主密钥传到第二物理密钥，然后把他妥善的保存好。如果你没有第二物理密钥的话，那么也无所谓，把上面导出的内容放到离线介质也是好的。</p><p>再次重复强调，这张第二物理密钥和保存密钥的介质应当长期离线，就算需要使用也应该在纯洁环境中使用。</p><h4 id="用第二物理密钥">用第二物理密钥</h4><p>简单说就是把当前的主密钥传输到一张智能硬件上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --expert --edit-key &lt;Your Key ID&gt;<br><br>gpg&gt; toggle<br>gpg&gt; keytocard<br>gpg&gt; save<br></code></pre></td></tr></table></figure><p>然后这张物理密钥就变成了保存你的主密钥的物理密钥，这张第二物理密钥应当平常不被使用，只有你需要再次签发新子密钥、更换密钥、注销子密钥的时候才使用。</p><h4 id="本地离线主密钥">本地离线主密钥</h4><p>只要我删掉主密钥不就行了吗？只要我导入只有子密钥的密钥不就行了吗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --delete-secret-keys [Your Key ID]<br></code></pre></td></tr></table></figure><p>然后再次输入<code>gpg -K</code>，如果他没什么输出那就对了。</p><p>我们再导入上文导出的<code>subkeys.sec</code>就行了。</p><p>让我们再次输入<code>gpg -K</code>，如果你看到一个<code>sec#</code>那就证明做的很正确，主密钥成功离线。</p><h3 id="把子密钥搬家到物理硬件">把子密钥搬家到物理硬件</h3><p>输入以下命令进入编辑密钥模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --expert --edit-key &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>然后把前面三个子密钥都搬家到物理密钥上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg&gt; key [Sub Key ID]<br>gpg&gt; keytocard<br>&gt; 重复选中全部三个，并且都 keytocard<br>gpg&gt; save<br></code></pre></td></tr></table></figure><p>在完成以上步骤后，是否我们就结束了？</p><p>并不是，我们还需要导出一个<code>stub.asc</code>。这个文件并没有实质内容，他告诉 GPG 需要从物理密钥里面寻找所需要的密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --output stubs.asc --export-secret-keys &lt;Your Key ID&gt;<br></code></pre></td></tr></table></figure><p>这个密钥可以随着你的常用介质走，导入到你需要的电脑上，他是安全的，因为不包含任何实际上的私钥。</p><p>同样的，推荐你把<code>pubkey.asc</code>和<code>stub.asc</code>放在一起。关于为什么下文会提到</p><h3 id="上传公钥">上传公钥</h3><p>你可以选择不做这步，因为上传公钥就能让全世界都能鉴定这是你。如果你是自己用的话就无所谓。</p><p>考虑到大多数情况下需要公开公钥，毕竟叫做 PubKey，所以推荐你做这一步。</p><p>现在的 KeyServer 会互相同步 Key，因此只需要简单的使用如下命令便可做到全世界的 KeyServer 都有你的 PubKey。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --send-key [Your Key ID]<br></code></pre></td></tr></table></figure><p>目前的 GPG KeyServer 默认为 <code>keyserver.ubuntu.com</code> ，是国内可以访问的，请放心食用捏。</p><p>上文提到的<code>pubkey.asc</code>为什么要和你的<code>stub.asc</code>放一起？因为一旦到了新设备，很可能新设备没联网，GPG 无法校验是否正确。</p><p>两个一起导入后 GPG 就能相信这是你了。</p><p>如果能联网哪？如果能联网，能与 KeyServer 通讯，并且已经上传了公钥，那么只需要做下面这一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --receive-key [Your Key ID]<br></code></pre></td></tr></table></figure><p>大功告成 uwu</p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://keyring.debian.org/creating-key.html">Debian Wiki - Creating a new GPG key</a></li><li><a href="https://wiki.debian.org/Smartcards/OpenPGP">Debian Wiki - Smartcards OpenPGP</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>捣鼓</category>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>捣鼓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用GPG签名告诉大家这就是我的提交</title>
    <link href="/2022/02/18/%E7%94%A8GPG%E7%AD%BE%E5%90%8D%E5%91%8A%E8%AF%89%E5%A4%A7%E5%AE%B6%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E6%8F%90%E4%BA%A4/"/>
    <url>/2022/02/18/%E7%94%A8GPG%E7%AD%BE%E5%90%8D%E5%91%8A%E8%AF%89%E5%A4%A7%E5%AE%B6%E8%BF%99%E5%B0%B1%E6%98%AF%E6%88%91%E7%9A%84%E6%8F%90%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>同学们早，大家签名 Commit 了吗？不签也可以，随便你。jpg</p><span id="more"></span><p>其实并不是我主动发现的这个功能，而是我看到了这些个洋葱新闻才发现了问题：</p><ul><li><a href="https://github.com/torvalds/linux/tree/8bcab0346d4fcf21b97046eb44db8cf37ddd6da0">Linus:我发现了那个叫做 WindowsXP 的系统很棒，Linux 是个垃圾系统</a></li></ul><p>好吧，还是搞搞 GPG 签名比较稳妥，虽然我的项目也不会有人这么搞就是了</p><div class="note note-success">            <p>本来这是 Github 很早前就有的漏洞了，他们说这个不影响。现在闹大了才勉强对这种情况标了个游离提交</p>          </div><p>Git 本身使用邮箱标注是谁的提交，这样就意味着可以随意冒充。但是新版本 Git 支持了 GPG 签名，这样就算 SSH Key 泄露了也能保证这个提交是你的了</p><div class="note note-success">            <p>Windows 的 git 已经包含了 GPG，不需要额外安装了。但是需要在 GitBash 下才能使用。不过 VSCode 也可以使用就是了</p>          </div><h2 id="验证是否已经有了-gpg-密钥">验证是否已经有了 GPG 密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --list-secret-keys --keyid-format LONG<br></code></pre></td></tr></table></figure><p>如果输出有的话，那么就不想要新建了</p><h2 id="新建-gpg-密钥">新建 GPG 密钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --full-generate-key<br></code></pre></td></tr></table></figure><p>可以一路回车，输入邮箱之类的推荐用在 Github 验证过的</p><p>其实按照 Github 的工作原理的话，邮箱也必须是在 Github <strong>验证</strong>过的</p><div class="note note-warning">            <p>密钥长度这一项一定要写 4096 长度，这是 <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key">Github 的要求</a></p>          </div><h2 id="导出公匙">导出公匙</h2><h3 id="列出所有密钥">列出所有密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --list-secret-keys --keyid-format=long<br></code></pre></td></tr></table></figure><p>举个例子，假设它的输出为下面这样</p><p>当然，你能通过时间看出来谁是最新的，最新的那个当然是你想要的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gpg --list-secret-keys --keyid-format=long<br>/Users/hubot/.gnupg/secring.gpg<br>------------------------------------<br>sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]<br>uid                          Hubot<br>ssb   4096R/42B317FD4BA89E7A 2016-03-10<br></code></pre></td></tr></table></figure><h3 id="复制以-sec-开头的-gpg-密钥-id">复制以 sec 开头的 GPG 密钥 ID</h3><p>根据上面一条的输出，所以它的密钥 ID 为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">3AA5C34371567BD2<br></code></pre></td></tr></table></figure><h3 id="导出该-id-的公钥">导出该 ID 的公钥</h3><p>根据上一步，接下来我们的命令会变成这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --armor --<span class="hljs-built_in">export</span> pub 3AA5C34371567BD2<br></code></pre></td></tr></table></figure><p>他会输出你的公钥，把它们全部粘贴复制到 Github 的 <a href="https://github.com/settings/keys">GPG Keys</a> 里面就行</p><h2 id="将-gpg-密钥与-git-关联">将 GPG 密钥与 Git 关联</h2><p>把上面的 ID 粘贴复制下来，输入下面这个命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.signingkey 3AA5C34371567BD2<br></code></pre></td></tr></table></figure><p>然后我们需要让 Git 默认用 GPG 签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global commit.gpgsign <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>大功告成</p>]]></content>
    
    
    <categories>
      
      <category>捣鼓</category>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS:深度优先搜索</title>
    <link href="/2022/02/18/DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/02/18/DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>暴力算法和 DFS 有什么区别？剪枝，回溯又是什么？</p><span id="more"></span><div class="note note-success">            <p>这是一篇给我自己看的笔记，用以备忘</p>          </div><p>在做蓝桥杯的题目时候遇到一个题目，它的描述如下</p><blockquote><p>小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。</p><p>有一次，老师出的题目是：<code>36 * 495 = ?</code></p><p>他却给抄成了：<code>396 * 45 = ?</code></p><p>但结果却很戏剧性，他的答案竟然是对的！！</p><p>因为 <code>36 * 495 = 396 * 45 = 17820</code></p><p>类似这样的巧合情况可能还有很多，比如：<code>27 * 594 = 297 * 54</code></p><p>假设 <code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code> 代表 1~9 不同的 5 个数字（注意是各不相同的数字，且不含 0）</p><p>能满足形如： <code>ab * cde = adb * ce</code> 这样的算式一共有多少种呢？</p><p>请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。</p><p>满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。</p></blockquote><p>人话来说，就是找出满足<code>ab * cde = adb * ce</code>的所有<code>a</code> <code>b</code> <code>c</code> <code>d</code> <code>e</code>，并且他们数值不会重复，且他们是处于 1-9 这个区间的</p><h2 id="解决方案">解决方案</h2><p>一共存在两种解决方案，暴力枚举和 DFS。</p><p>暴力枚举能比较简单的解决问题，但是它需要走所有的可能才能得出结果，优点在于思想简单容易理解</p><p>DFS 解决它的方法可能相对复杂，但是它不不想要知道所有的可能，他会在触碰边界后回退到上一步尝试下一种可能。</p><div class="note note-success">            <p>重点讲解理解 DFS</p>          </div><p>跳出这种可能，即为<strong>剪枝</strong>。</p><p>回退到上一步尝试下一种可能，即为<strong>回溯</strong>。</p><h3 id="暴力枚举">暴力枚举</h3><p>我们假设一共有<code>a</code>，<code>b</code>，<code>c</code>，<code>d</code>，<code>e</code>五个循环，其中初始化数据均为 1，包裹顺序为 <code>a</code> 包裹 <code>b</code> 包裹 <code>c</code> 包裹 <code>d</code> 包裹 <code>e</code>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; a &lt; <span class="hljs-number">10</span>; a++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; b &lt; <span class="hljs-number">10</span>; b++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; c &lt; <span class="hljs-number">10</span>; c++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; d &lt; <span class="hljs-number">10</span>; d++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; e &lt; <span class="hljs-number">10</span>; e++) &#123;<br>                    <span class="hljs-comment">// 跳出条件</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>能暴力枚举出所有可能，但是这个不是我们的最佳解法——它的范用性非常的差</p><h3 id="dfs深度优先搜索">DFS，深度优先搜索</h3><p>DFS 一般和全排列在一起，它也能列举出所有的可能并且会尽可能深的访问数据结构，但是它有剪枝和回溯能力以及固定的代码格式，相比之下它有了更强的范用性</p><p>它的关键字为：<code>回溯</code>，<code>递归</code>，<code>剪枝</code></p><p>以下为它的伪代码表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这是当前的数据数组，需要看情况调整</span><br>ArrayList&lt;Integer&gt; numCombine = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 需要假设最远步数</span><br><span class="hljs-type">int</span> maxStep;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsRun</span><span class="hljs-params">(<span class="hljs-type">int</span> step)</span> &#123;<br>    <span class="hljs-comment">// 边界，maxStep为步数边界</span><br>    <span class="hljs-keyword">if</span> (step == <span class="hljs-built_in">this</span>.maxStep) &#123;<br>        <span class="hljs-comment">// 已经到达了边界，需要跳出这一条线路</span><br>        dfsCheck();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 递归条件</span><br>    <span class="hljs-comment">// for语句中填充初始化条件</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 跳出条件，意味着当前分支已经失败</span><br>        <span class="hljs-comment">// 这里就是剪枝操作</span><br>        <span class="hljs-keyword">if</span>()<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">this</span>.numCombine.add(i);<br>        <span class="hljs-comment">// 走下一步</span><br>        <span class="hljs-built_in">this</span>.dfsRun(step + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 回溯，因为这个条件已经判断过了，需要回退一步</span><br>        <span class="hljs-built_in">this</span>.numCombine.remove(<span class="hljs-built_in">this</span>.numCombine.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsCheck</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这里写检查条件</span><br>    <span class="hljs-comment">// 当检查成功时，可以把它储存起来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是 DFS 的模板代码了。</p><p>用文字的方法来理解它：</p><blockquote><p>1.首先将根节点放入 stack 中。 2.从 stack 中取出第一个节点，并检验它是否为目标。</p><blockquote><p>如果找到目标，则结束搜寻并回传结果。 否则将它某一个尚未检验过的直接子节点加入 stack 中。</p></blockquote><p>3.重复步骤 2。 4.如果不存在未检测过的直接子节点。</p><blockquote><p>将上一级节点加入 stack 中。 重复步骤 2。</p></blockquote><p>5.重复步骤 4。 6.若 stack 为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</p></blockquote><p>理解起来很困难对吧，没关系来看下面资料继续理解 XD</p><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2#:~:text=%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%20%EF%BC%88%E8%8B%B1%E8%AF%AD%EF%BC%9A%20Depth-First-Search%20%EF%BC%8C%20DFS%20%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86%E6%88%96%E6%90%9C%E7%B4%A2%20%E6%A0%91%20%E6%88%96,%5B%E6%9D%A5%E6%BA%90%E8%AF%B7%E6%B1%82%5D%20%E3%80%82.%20%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%98%AF%E5%9B%BE%E8%AE%BA%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BA%A7%E7%94%9F%E7%9B%AE%E6%A0%87%E5%9B%BE%E7%9A%84%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20%E8%A1%A8%20%EF%BC%8C%E5%88%A9%E7%94%A8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E8%A1%A8%E5%8F%AF%E4%BB%A5%E6%96%B9%E4%BE%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%BE%88%E5%A4%9A%E7%9B%B8%E5%85%B3%E7%9A%84%20%E5%9B%BE%E8%AE%BA%20%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E6%97%A0%E6%9D%83%E6%9C%80%E9%95%BF%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E7%AD%89%E7%AD%89%E3%80%82.">WikiPedia：深度优先搜索</a></li><li><a href="https://github.com/SUIBING112233/CodeRecords/tree/main/%E8%93%9D%E6%A1%A5%E6%9D%AF/4/B2">我的代码仓库：L4B2</a></li></ul><blockquote><p>用到的资源 由 Alexander Drichel - 自己的作品，CC BY-SA 3.0，<a href="https://commons.wikimedia.org/w/index.php?curid=3791979" class="uri">https://commons.wikimedia.org/w/index.php?curid=3791979</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章翻译:从init.vim到init.lua</title>
    <link href="/2021/12/20/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91-%E4%BB%8Einit-vim%E5%88%B0init-lua/"/>
    <url>/2021/12/20/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91-%E4%BB%8Einit-vim%E5%88%B0init-lua/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>原文链接：<a href="https://www.notonlycode.org/neovim-lua-config/">5 分钟速成课程：从 init.vim 到 init.lua，释放 Neovim 0.5 的威力!</a></p><span id="more"></span><p>今年早些时候，Neovim 的维护者们发布了 0.5 版本。除了很多其他的功能，这个版本有一个很重大的新功能：允许用户使用 Lua 语言配置他们的 Neovim 编辑器。</p><p>在这篇文章我会分享一些关于如何从由 VimL 编写的配置文件搬家到由 Lua 编写的配置文件的基础规则。这不是一个完整的指南，但是他覆盖了我转移我的 init.vim 转移到 init.lua 所需要用到的几乎 100% 的知识。</p><p>在文章的底部，你还可以找到我的配置文件的链接，你可以把他们当作你学习的例子。如果需要的话，你可以复制他们。</p><h2 id="分钟速成-lua">1 分钟速成 Lua</h2><p>首先，最好花 10-15 分钟学习 Lua，以便轻松编写新配置。我是在“<a href="https://learnxinyminutes.com/docs/lua/">在 Y 分钟内学习 X</a>”网站借鉴的 Lua 例子，我觉得他们能完全工作。如果你想用一分钟的时间学会 Lua 语言，来看看下面这个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 这是一个注释</span><br>num = <span class="hljs-number">22</span> <span class="hljs-comment">-- 这是一个声明了number类型的全局变量</span><br><span class="hljs-keyword">local</span> num2 = <span class="hljs-number">33</span> <span class="hljs-comment">-- 本地变量</span><br>str1 = <span class="hljs-string">&#x27;this is a string&#x27;</span><br>str2 = <span class="hljs-string">&quot;and so is this&quot;</span><br>str3 = <span class="hljs-string">[[ and this is a string too ]]</span><br>str4 = <span class="hljs-string">&quot;string &quot;</span> .. <span class="hljs-string">&quot;concatenation&quot;</span><br>val = <span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">false</span> <span class="hljs-comment">-- 布尔和逻辑操作符</span><br><br><span class="hljs-keyword">if</span> str1 == <span class="hljs-string">&#x27;something&#x27;</span> <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;YES&quot;</span>)<br><span class="hljs-keyword">elseif</span> str2 ~= <span class="hljs-string">&#x27;is not equal&#x27;</span> <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Maybe&#x27;</span>)<br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;no&#x27;</span>)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printText</span><span class="hljs-params">(text)</span></span><br>  <span class="hljs-built_in">print</span>(text)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">end</span><br><br>tab1 = &#123; <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is, &#x27;</span>a<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-built_in">table</span><span class="hljs-string">&#x27; &#125; -- 一个数组</span><br><span class="hljs-string">tab2 = &#123; also = &#x27;</span>this is a <span class="hljs-built_in">table</span><span class="hljs-string">&#x27; &#125; -- 表是数组和词典类型的组合</span><br><span class="hljs-string">tab2[&quot;new_key&quot;] = &quot;new value&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">print(tab2[&quot;also&quot;])</span><br><span class="hljs-string"></span><br><span class="hljs-string">require(&#x27;</span>plugins<span class="hljs-string">&#x27;) -- 这个语句会查找lua文件并且执行他</span><br></code></pre></td></tr></table></figure><p>当然这个简短的课程以外还有很多的内容需要学，但是对于我来说从这个简短的课程以及插件文档中复制一些东西就足够编写我的配置文件了</p><h2 id="配置文件基础教学">配置文件基础教学</h2><p>好！现在我们看向我们的配置文件。在 Vim 当中我们使用了一系列的方法去配置我们的编辑器（整个 VimL 语言都在致力于这件事，真的）。那么我们现在要学会如何用通用语言 Lua 和 Neovim 的 API 去与 Neovim 的配置项目交互：</p><ul><li><code>vim.cmd("set notimeout")</code> 这是一个安全操作，无论你向<code>vim.cmd</code>传输了什么字符串，他们都会被转义成为 VimL。可能你想一次性写几行，那么你需要使用双方括号来做这件事</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.cmd(<span class="hljs-string">[[</span><br><span class="hljs-string">set notimeout</span><br><span class="hljs-string">set encoding=utf-8</span><br><span class="hljs-string">]]</span>)<br></code></pre></td></tr></table></figure><ul><li><code>vim.g.mapleader = ","</code>等价于<code>let g:mapleader = ','</code>；<code>vim.g</code>是一个代表全局变量的表</li><li><code>vim.o.encoding="utf-8"</code>等价于<code>set encoding=utf-8</code>；其中：<ul><li><code>vim.o</code>用于全局设置</li><li><code>vim.wo</code>用于窗口设置</li><li><code>vim.bo</code>用于缓冲设置</li></ul></li><li><code>vim.fn</code>是一个存放函数的表，你可以使用 <code>vim.fn.thisIsMyFun</code> 或 <code>vim.fn["thisIsMyFun"]</code> 引用一个函数 <code>thisIsMyFun</code>；你可以使用 <code>vim.fn.thisIsMyFun()</code> 或 <code>vim.fn["thisIsMyFun"]()</code> 调用它</li><li><code>vim.api</code>是一个 API 函数合集。我只用了一个：<code>vim.api.nvim_set_keymap</code>。他能映射我的按键组合到一些方法上（继续看，更多内容在下面）</li></ul><h2 id="是时候搬家到-lua-编写的配置文件了">是时候搬家到 Lua 编写的配置文件了</h2><p>移动大部分设置非常简单。你只需将 <code>set x = y</code> 替换为 <code>vim.o.x = "y"</code>就可以了。然而，其他的时候可能会遇到一些问题：</p><ul><li>成对的布尔设置被合并为一个设置，例如，你可以用 <code>vim.o.wrap = true</code> 和 <code>vim.o.wrap = false</code> 来代替 <code>set wrap</code> 和 <code>set nowrap</code>。</li><li>HOME 目录问题： 我在使用 <code>~</code> 作为对某些备份文件等的主目录的引用时遇到问题，所以我通过编写 <code>HOME = os.getenv("HOME")</code> 来设置我使用的 HOME 变量</li><li>字符串连接使用 <code>..</code> 运算符，因此为了引用我的备份目录，要写成 <code>vim.o.backupdir = HOME .. "/.vim/backup"</code></li><li>双反斜杠： 如果你想传递一个特殊字符 <code>\t</code> 给 Neovim，你需要在 Lua 中把它写成 <code>"\\t"</code></li></ul><h2 id="键位映射">键位映射</h2><p>Lua API 具有将键映射到某些函数的功能。函数签名是 <code>vim.api.nvim_set_keymap(mode, keys, mapping, options)</code>，其中 <code>mode</code> 是指代表编辑器模式的字母（<code>n</code> 表示正常，<code>i</code> 表示插入等），就像在 <code>nmap</code> 或 <code>imap</code> 等原始 vim 函数中一样， <code>keys</code> 是一个表示键组合的字符串，<code>mapping</code> 是一个表示键映射到什么的字符串，<code>options</code> 是一个表，你可以在其中传递一些附加设置。</p><p>举个例子</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">vim.api.nvim_set_keymap(<br>  <span class="hljs-string">&quot;n&quot;</span>,<br>  <span class="hljs-string">&quot;&lt;leader&gt;a&quot;</span>,<br>  <span class="hljs-string">&quot;:Git blame&lt;cr&gt;&quot;</span>,<br>  &#123; noremap = <span class="hljs-literal">true</span> &#125;<br> )<br></code></pre></td></tr></table></figure><p>这个函数等价于 <code>nnoremap &lt;leader&gt;a &lt;cmd&gt;Git blame&lt;cr&gt;</code></p><p>我没有检查可以在第 4 个参数中传递的所有选项是什么，我所用到的两个是 <code>noremap = true</code> 和 <code>Silent = true</code>。</p><p>我还给自己写了一些简单的函数，以避免每次都输入 <code>vim.api...</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span><span class="hljs-params">(mode, shortcut, command)</span></span><br>  vim.api.nvim_set_keymap(mode, shortcut, command, &#123; noremap = <span class="hljs-literal">true</span>, silent = <span class="hljs-literal">true</span> &#125;)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nmap</span><span class="hljs-params">(shortcut, command)</span></span><br>  map(<span class="hljs-string">&#x27;n&#x27;</span>, shortcut, command)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imap</span><span class="hljs-params">(shortcut, command)</span></span><br>  map(<span class="hljs-string">&#x27;i&#x27;</span>, shortcut, command)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>有了这些函数，我上面的例子就变成了 <code>nmap("&lt;leader&gt;a", "&lt;cmd&gt;Git blame&lt;cr&gt;")</code>，相比之下，可读性也变得更好了。</p><h2 id="包管理器">包管理器</h2><p>很有可能你已经使用了一些包管理器，当你转向 Lua 时你不需要更改它，你只需将整个插件列表包装在 <code>vim.cmd</code> 中并像以前一样继续使用它。</p><p>我决定尝试一个名为 <a href="https://github.com/wbthomason/packer.nvim">Packer</a> 的新包管理器，它是用 Lua 编写的，所以需要 Neovim 0.5 才能使用。安装有点麻烦，因为我不知道 <code>packpath</code> 是什么，那个 Packer 需要一些非常具体的目录名称才能找到包。捣鼓了一阵子后，我将它移动到 <code>~/.config/nvim/pack/packer/start/packer.nvim</code> 目录并且它运行良好（尽管我确定有更好的安装方法）。</p><p>虽然安装有点麻烦，但是 Packer 易于使用，还有我需要的所有功能（还有很多我不需要的功能）。基本配置示例如下所示：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;packer&#x27;</span>).startup(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span><br>  use <span class="hljs-string">&#x27;wbthomason/packer.nvim&#x27;</span><br><br>  <span class="hljs-comment">-- common</span><br>  use <span class="hljs-string">&#x27;tpope/vim-fugitive&#x27;</span> <span class="hljs-comment">-- Git commands</span><br>  use &#123; <span class="hljs-string">&#x27;tpope/vim-rails&#x27;</span>, ft = <span class="hljs-string">&quot;ruby&quot;</span> &#125; <span class="hljs-comment">-- only load when opening Ruby file</span><br><span class="hljs-keyword">end</span>)<br></code></pre></td></tr></table></figure><p>如果你需要一些更高级的功能，我建议你查看文档。</p><h2 id="其他插件">其他插件</h2><p>除此之外还有很多很多能适用于 Neovim 0.5 的插件，并且我自己用新的替代品替换了我以前使用过的一些插件。我不会在这里介绍它们（可能在另一篇文章中）但是还是可以简单的看看他们：</p><ul><li>把<code>nvim-lspconfig</code> 与 <code>nvim-lspinstall</code> 和 <code>lspsaga.nvim</code> 搭配起来一起使用，他们能使用 Neovim 中新的内置 LSP 并提供一些有用的功能。它们让我可以轻松安装和使用语言服务器（例如，显示功能文档或跳转到定义）。再加上 <code>nvim-compe</code>（自动补全插件），我用它们来代替原来的 <code>Ale</code> 和 <code>coc.vim</code>，</li><li><code>telescope.nvim</code> 替换你使用的任何搜索插件（<code>ctrl-p</code>, <code>fzf.vim</code> 等）。</li><li><code>gitsigns</code> 替换 <code>vim-gitgutter</code></li></ul><h2 id="总结">总结</h2><p>把 350 行 <code>init.vim</code> 移到 <code>init.lua</code> 的整个过程花了我大约 2 小时，包括整理文件的时间（Lua 允许你使用多个配置文件，见我下面的例子），不包括玩新插件的时间。我花了大约 1 个小时来移动 90-95%的内容，另外花了 1 个小时来解决一些问题，如主目录或一些坏掉的的配置。最后我发现整个过程相当快，而且绝对收益良多，虽然我确信很多事情可以做得更好。如果你打算使用 Neovim 0.5 的新功能，我肯定会建议将你的配置转移到 Lua。</p><p><strong>我在 VimL 和 Lua 中的配置：<a href="https://github.com/arnvald/viml-to-lua" class="uri">https://github.com/arnvald/viml-to-lua</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搬运</tag>
      
      <tag>翻译</tag>
      
      <tag>文章</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目录遍历攻击</title>
    <link href="/2021/10/27/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%94%BB%E5%87%BB/"/>
    <url>/2021/10/27/%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在进行 Reposite 开发的过程之中遇到了访问本地文件的需求，同时又需要暴露文件。在查看 rocket.rs 的文档寻找这部分文档之时知道了 <em>目录遍历攻击(directory traversal attack)</em> 。</p><span id="more"></span><h2 id="形成攻击">形成攻击</h2><p>假设我们提供了一个 http 服务器，他可有访问静态文件的功能，您可以用 GET 方法访问 API 获取文件。这里使用 Rust 的 rocket.rs 框架功能演示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[get(<span class="hljs-string">&quot;/page/&lt;path..&gt;&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_page</span>(path: PathBuf) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>假设我们的程序执行位置为 <code>/home/iced/reposite/</code> ，那么我们使用以下 GET 方法</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">GET http://127.0.0.1:8000/page/../../../etc/passwd<br></code></pre></td></tr></table></figure><p>就可能访问到敏感文件。</p><p>同时由于 <a href="https://www.w3cschool.cn/htmltags/html-urlencode.html">URL 转义</a>，以下请求是等效于以上请求的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">GET http://127.0.0.1:8000/page/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd<br></code></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">GET http://127.0.0.1:8000/page/%2e%2e/%2e%2e/%2e%2e/etc/passwd<br></code></pre></td></tr></table></figure><h2 id="如何解决">如何解决？</h2><p>根据以上分析，以及 rocket.rs 的文档来看，我们有三种下手解决他的办法。</p><ul><li>由框架解决</li><li>从参数上解决</li><li>手动识别路径</li><li>容器化</li></ul><h3 id="使用框架提供的功能">使用框架提供的功能</h3><p>rocket.rs 提供<a href="https://rocket.rs/v0.5-rc/guide/requests/">静态文件服务</a>，他们推荐使用这个服务替代手写的访问文件功能。</p><h3 id="编写-pathwarden">编写 PathWarden</h3><p>假设程序运行目录为<code>/home/iced/reposite/</code>，传入的 http 请求想要访问<code>../../../etc/passwd</code>，此路径永远为相对路径。</p><p>我们可以把参数给转换为绝对路径<code>/home/iced/reposite/../../../etc/passwd</code>，在展开路径后变成了<code>/etc/passwd</code>。</p><p>注意到了吗，到这里位置这个路径已经不包含程序运行目录，他访问越界了。于是在这里我们可以直接判断目标路径是否包含程序运行目录。如果包含的话允许访问，如果不包含的话立刻返回 http 状态码 <code>416</code>，<code>404</code> 等</p><h3 id="参数禁止">参数禁止</h3><p>不允许请求访问的文件目录中包含<code>../</code>，<code>%2e%2e/</code>，<code>%2e%2e%2f</code>等特殊字符组合。如果包含的话立刻返回 http 状态码 <code>416</code>，<code>404</code> 等</p><h3 id="容器化">容器化</h3><p>容器作为隔离资源的一种方案也能有效简单的解决这个问题。</p><p>假设容器内<code>/home/reposite/</code>被挂载上了内容作为工作目录，那么如果访问越界的话只会访问到容器内的内容，并不会对主机造成实质性伤害。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何挂载.img文件，以及如何使用QEMU模拟arm64环境</title>
    <link href="/2021/08/04/%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD-img%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9Farm64%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/08/04/%E5%A6%82%E4%BD%95%E6%8C%82%E8%BD%BD-img%E6%96%87%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8QEMU%E6%A8%A1%E6%8B%9Farm64%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在上一篇中编译 OpenCV 成功之后我把整个树莓派的 TF 卡使用 dd 命令导出成了 .img 文件作为备份。我会暂时有一段时间无法接触到我的树莓派，并且我还有很多步骤没有完成。</p><p>所以我就想是否能挂载到 x86 Linux host 上进行操作？</p><span id="more"></span><h2 id="如何-dd-出系统镜像文件">如何 dd 出系统镜像文件？</h2><p>使用大部分 Linux 发行版都自带的 dd 命令即刻。</p><p>想象一下当初你是如何使用 dd 命令制作 Linux 的 LiveCD 的？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=&lt;the_path_to_ISO_file&gt; of=/dev/sdx<br></code></pre></td></tr></table></figure><p>其中 <code>/dev/sdx</code> 为<strong>设备文件</strong>，通常他们存在于 <code>/dev/</code> 目录之下.</p><p>那我们再想一想是不是可以反过来？</p><p>于是得出了以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sdx of=rpimg.img<br></code></pre></td></tr></table></figure><p>注意，这里必须为设备文件而不是设备分区文件，除非你想备份分区。</p><p>由于 TF 卡大小为 64GiB，换算为 GB 单位则为 60GB，是非常庞大的数据量，由于 Linux 系统调度的特性所以卡顿是很正常的现象。我的 TF 卡搭配 USB3.0 读卡器经过测试这个过程将会持续十分钟。</p><h2 id="奇怪的想法">奇怪的想法</h2><p>在思考是否可以在 x86 Linux host 上进行操作的时候我产生了一些疑问：</p><ul><li>此时的 img 文件为何种格式？</li><li>是否可以使用 chroot 以及 QEMU 操作 img 文件内内容？</li></ul><h2 id="验证奇怪的想法">验证奇怪的想法</h2><h3 id="qemu-是否可以模拟运行-arm64aarch64">QEMU 是否可以模拟运行 arm64（aarch64）？</h3><p>经过资料的查找我们可以发现树莓派所使用的 SoC 为博通 BCM2711，大架构属于 ARM v8。</p><p>因此需要查找 QEMU 现在是否可以模拟 ARM v8</p><p>在 debian 的软件包搜索当中我们发现 <code>qemu-user-static</code> <a href="https://packages.debian.org/bullseye/qemu-user">软件包</a>中有如下描述</p><blockquote><p>QEMU is a fast processor emulator: currently the package supports <strong>ARM</strong>, CRIS, i386, M68k (ColdFire), MicroBlaze, MIPS, PowerPC, SH4, SPARC and x86-64 emulation. By using dynamic translation it achieves reasonable speed while being easy to port on new host CPUs.</p><p>This package provides the user mode emulation binaries. In this mode QEMU can <strong>launch Linux processes compiled for one CPU on another CPU</strong>.</p></blockquote><p>感觉上大概是完全可以的。</p><p>选择 <code>user mode</code> 的 QEMU 而不是 <code>system mode</code> ，原因有二</p><ol type="1"><li>我们目标是挂载 img 并且使用 chroot 运行</li><li>这里使用 chroot jail 并不需要启动整个系统，相对而言其实是一套软件，因此是用户态。</li></ol><p><strong>另外这里并不是虚拟机。</strong> chroot 本质上只是变更当前进程及其子进程的可见根路径。变更后，程序无法访问可见根目录外文件和命令。<strong>chroot 的大欺骗战术！</strong></p><p>另外其实可以不使用 chroot，使用 Fakechroot 以及 PRoot 也是可以的</p><p>关于 PRoot 以及 Fakechroot 的用法可以参照以下链接</p><ul><li><a href="http://manpages.ubuntu.com/manpages/precise/man1/fakechroot.1.html">Fakechroot</a></li><li><a href="https://wiki.archlinux.org/title/PRoot">PRoot</a></li></ul><p>使用如下命令安装 <code>qemu-user-static</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt install -y qemu-user-static<br></code></pre></td></tr></table></figure><p>他会自动配置 binary handle，如果执行的二进制文件架构是 qemu 支持的但是不是本机架构的话会自动使用 qemu 运行。</p><h3 id="img-文件分析">img 文件分析</h3><h4 id="逻辑">逻辑</h4><p>还记得上文中所提到的<code>设备文件</code>吗？在 Linux 当中把和设备交互的地方抽象成为了一个文件。</p><p>再联想一下 Linux 系统（乃至于各种 unix like 系统）当中的一个很大的特性：<strong>一切皆文件</strong>。</p><p>我们是从 TF 卡中完整的复制内容到 img 文件，那么是否在这个 img 文件当中包含了分区信息？</p><p>如果说我们知道了 img 文件当中的分区的起始点与结束点，那么他不就可以被抽象成为类似设备文件一样的东西了吗？</p><h4 id="验证由-dd-设备文件而来的-img-文件是否拥有完整的分区格式">验证由 dd 设备文件而来的 img 文件是否拥有完整的分区格式</h4><p>祭出我们常用的<code>fdisk</code>命令，其堪称操作设备文件的瑞士军刀。</p><p>对 img 文件使用以下命令。我的 img 文件名为 rpios.img。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo fdisk -l rpimg.img<br></code></pre></td></tr></table></figure><p>他输出了以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">Disk rpimg.img: 59.69 GiB, 64088965120 bytes, 125173760 sectors<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: dos<br>Disk identifier: 0xf9f150b0<br><br>Device     Boot  Start       End   Sectors  Size Id Type<br>rpimg.img1        8192    532479    524288  256M  c W95 FAT32 (LBA)<br>rpimg.img2      532480 125173759 124641280 59.4G 83 Linux<br><br></code></pre></td></tr></table></figure><p>fdisk 对 img 文件成功读取了分区信息，并且认为他是一个<strong>合法的设备</strong>。</p><h4 id="挂载-img-文件使其内部可以被操作">挂载 img 文件，使其内部可以被操作</h4><p>在<a href="https://man7.org/linux/man-pages/man4/loop.4.html">man pages</a>上写道</p><blockquote><p>The loop device is a block device that maps its data blocks not to a physical device such as a hard disk or optical disk drive, but to the blocks of a regular file in a filesystem or to another block device. This can be useful for example to provide a block device for a filesystem image stored in a file, so that it can be mounted with the mount(8) command.</p></blockquote><p>其上大概解释就是<code>loop device（回环设备）</code>是由<code>块设备</code>映射成的文件，</p><p><code>mount</code>命令的 man pages 有如下一段解释</p><blockquote><p>If no explicit loop device is mentioned (but just an option `-o loop' is given), then mount will try to find some unused loop device and use that, for example</p><p>mount /tmp/disk.img /mnt -o loop</p></blockquote><p>但是他挂载的 img 文件是单分区的，而我们的 img 文件含有多个分区</p><blockquote><p>This type of mount knows about three options, namely loop, offset and sizelimit, that are really options to losetup(8). (These options can be used in addition to those specific to the filesystem type.)</p></blockquote><p>所以如果我们镜像如果是多分区，我们可以使用 offset 和 sizelimit 参数来挂载。由于是最后一个分区所以我们就偷懒不写 sizelimit 了。</p><p>因此我们的命令就会如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> mp <span class="hljs-comment"># 新建 img 文件挂载到的文件夹，把分区挂在这里</span><br>sudo mount ./rpimg.img ./mnt -o loop,offset=$((<span class="hljs-number">532480</span> * <span class="hljs-number">512</span>)) -t ext4<br></code></pre></td></tr></table></figure><blockquote><p>有可能遇到 loop 设备被占用的情况，这个时候我们需要使用 losetup -f 命令获取哪个 loop 设备可用。</p></blockquote><p>由于第一个分区是启动分区而且我们不操作他，所以我们不挂载他。</p><p>这里输入成功后是无回显的，证明他成功了</p><p>于是我们<code>ls mnt</code>看看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">bin  boot  data  dev  etc  home  lib  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p>是完整的根目录结构，意味着我们的目的成功了！</p><h3 id="使挂载-img-后的内容成为-chroot-jail">使挂载 img 后的内容成为 chroot jail</h3><p>在 <a href="https://wiki.debian.org/chroot">debian wiki</a> 上写了 chroot 的用法（英文）</p><p>同时 <a href="https://wiki.archlinux.org/title/Chroot_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">arch wiki</a> 上也有 chroot 用法的介绍</p><p>最关键的部分如下</p><ul><li>绑定 /sys 到 rootfs 的 sys 文件夹</li><li>绑定 /dev 到 rootfs 的 dev 文件夹</li><li>绑定 /proc 到 rootfs 的 proc 文件夹</li><li>复制本机的 DNS 服务器配置文件到 rootfs</li></ul><p>其中由于树莓派系统的 rootfs 自带了 DNS 配置文件，所以我们不需要再复制本机的 DNS 配置文件。</p><p>因此我们可以得出以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> mnt                                  <span class="hljs-comment"># 切换到 img 文件的挂载文件夹</span><br>sudo mount --<span class="hljs-built_in">bind</span> /proc proc                 <span class="hljs-comment"># 挂载 proc</span><br>sudo mount --<span class="hljs-built_in">bind</span> /dev dev                   <span class="hljs-comment"># 挂载 dev</span><br>sudo mount --<span class="hljs-built_in">bind</span> /sys sys                   <span class="hljs-comment"># 挂载 sys</span><br><span class="hljs-comment">#cp -L /etc/resolv.conf etc/resolv.conf # 复制 DNS 配置文件，可选</span><br></code></pre></td></tr></table></figure><p>最后我们尝试使用 chroot 启动他。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo <span class="hljs-built_in">chroot</span> . /bin/bash<br></code></pre></td></tr></table></figure><p>可以看到标识符发生了变化，那么意味着我们成功的挂载了 img 文件并且进入了其中。</p><h3 id="卸载-img-文件的挂载">卸载 img 文件的挂载</h3><p>当我们对 img 文件操作完毕后需要卸载 img 文件的挂载才算是完成了工作。</p><p>当然最简单的方法就是重启系统了，全自动卸载。我们这里使用手动卸载节约时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo losetup -d /dev/loop0  <span class="hljs-comment"># 卸载回环设备</span><br>sudo umount ./mnt/dev       <span class="hljs-comment"># 卸载 dev 绑定</span><br>sudo umount ./mnt/proc      <span class="hljs-comment"># 卸载 proc 绑定</span><br>sudo umount ./mnt/sys       <span class="hljs-comment"># 卸载 sys 绑定</span><br>sudo umount ./mnt           <span class="hljs-comment"># 卸载 img 文件挂载</span><br>sudo <span class="hljs-built_in">sync</span>                   <span class="hljs-comment"># 同步更改到磁盘</span><br></code></pre></td></tr></table></figure><p>OK，大功告成。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>嵌入式</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>捣鼓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在树莓派上编译 OpenCV</title>
    <link href="/2021/08/02/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BC%96%E8%AF%91OpenCV/"/>
    <url>/2021/08/02/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%BC%96%E8%AF%91OpenCV/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近由于比赛需要在树莓派上使用 OpenCV，需要编译 OpenCV。所以写了这篇文章方便记忆。</p><span id="more"></span><h2 id="环境">环境</h2><ul><li>RaspberryPi 4 Model B (8GB RAM)</li><li>Raspbian GNU/Linux 10 (buster) armv7l</li></ul><p>考虑到树莓派 4B 性能与上一代相比较更加出色，并且我又懒得在笔记本上进行交叉编译，所以需要选用更加快速的编译方案</p><p>OpenCV 官方支持 clang 编译器与 ninja 编译系统。</p><p>clang 编译器有着不俗的编译速度，ninja 构建系统编译较为智能快速。</p><p>综合思考我决定使用 ninja 作为编译系统，使用 clang 作为编译器</p><h2 id="步骤">步骤</h2><h3 id="安装编译依赖">安装编译依赖</h3><p>在 OpenCV 的官方文档中写着使用如下命令安装依赖.</p><p>另外由于我们使用 clang 编译器与 ninja 构建系统所以我们需要安装 clang，llvm 以及 ninja</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo aptitude update &amp;&amp; sudo apt install -y cmake wget unzip clang llvm ninja-build<br></code></pre></td></tr></table></figure><p>得益于 debian 系系统的强大包管理系统，我们可以直接使用 apt 进行编译依赖安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo aptitude build-dep libcv-dev<br></code></pre></td></tr></table></figure><h3 id="克隆源码">克隆源码</h3><p>我们需要克隆两个仓库的源码：core modules 仓库以及 opencv_contrib 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git <span class="hljs-built_in">clone</span> https://github.com/opencv/opencv.git<br>git <span class="hljs-built_in">clone</span> https://github.com/opencv/opencv_contrib.git<br></code></pre></td></tr></table></figure><p>同时记得检出仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git -C opencv checkout master<br>git -C opencv_contrib checkout master<br></code></pre></td></tr></table></figure><p>另外如果想安装定向版本的话则可以选择检出 tags</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git -C opencv checkout &lt;tag&gt;<br>git -C opencv_contrib checkout &lt;tag&gt;<br></code></pre></td></tr></table></figure><p>当然我们这里检出 master 分支就行</p><p>新建 build 文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> -p build &amp;&amp; <span class="hljs-built_in">cd</span> build<br></code></pre></td></tr></table></figure><h3 id="初始化-ninja-构建系统">初始化 ninja 构建系统</h3><p>随后让 cmake 生成 ninja 所使用的文件,让他用 clang 进行编译。</p><p>我们这里不让他编译 example，这样编译速度会快不少。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">cmake -GNinja \<br>  -D CMAKE_C_COMPILER=clang-9 \<br>  -D CMAKE_CXX_COMPILER=clang++-9 \<br>  -D ENABLE_NEON=ON \<br>  -D ENABLE_VFPV3=ON \<br>  -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules ../opencv<br></code></pre></td></tr></table></figure><p>但是注意了，其实这里的 neon 指令集是启动失败的</p><p>也就是说性能不会太好，目前暂时没有解决方案。</p><h3 id="构建与安装">构建与安装</h3><p>使用如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">ninja &amp;&amp; sudo ninja install<br></code></pre></td></tr></table></figure><p>对，就是如此简单，ninja 自动设置线程数等。成功构建之后自动安装。</p><p>大功告成。</p><h3 id="同步上游更改">同步上游更改</h3><p>得益于 ninja 的特性，我们可以很方便的同步更改并且增量更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> opencv/<br>git fetch &amp;&amp; git pull &amp;&amp; <span class="hljs-built_in">cd</span> ../       <span class="hljs-comment"># 同步上游更改</span><br><span class="hljs-built_in">cd</span> opencv_contrib/<br>git fetch &amp;&amp; git pull &amp;&amp; <span class="hljs-built_in">cd</span> ../build  <span class="hljs-comment"># 同步上游更改并且回到 build 文件夹</span><br>ninja                                 <span class="hljs-comment"># 如果需要重新 cmake 的话 ninja 会自动执行，随后执行增量编译</span><br>sudo ninja install<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
      <category>嵌入式</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>捣鼓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于卸载BlueStacks后遇到的问题</title>
    <link href="/2021/06/27/%E5%85%B3%E4%BA%8E%E5%8D%B8%E8%BD%BDBlueStacks%E5%90%8E%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/27/%E5%85%B3%E4%BA%8E%E5%8D%B8%E8%BD%BDBlueStacks%E5%90%8E%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>BlueStacks 是一个超强的安卓模拟器，由于最近有需求所以安装了一个 BlueStacks。但是在遇到了一系列问题后我决定卸载，然而因此我又遇到了一系列问题......</p><span id="more"></span><h2 id="为什么我要卸载-bluestacks">为什么我要卸载 BlueStacks？</h2><p>因为他不和 HyperV 兼容，虽然 BlueStacks5 兼容，但是他不能打开 Root，所以我把他卸载了。</p><p>虽然 BlueStacks4 有 HyperV 兼容版本，但是几乎随时都在崩溃，所以也抛弃了。</p><p>在我安装完毕 BlueStacks5 后我发现我的 Docker 服务启动失败，仔细一想应该是 HyperV 被 BlueStacks5 的引擎占用了所以<em>没有在意</em>，在卸载 BlueStacks5 后甚至以为<em>重启一下</em>就行，但是我错了，<strong>错的还非常严重</strong>。</p><p><strong>噩梦就此开始。</strong></p><h2 id="噩梦">噩梦</h2><p>首先我的 Docker 服务启动失败了,</p><figure><img src="error1.png" alt="" /><figcaption>DockerError</figcaption></figure><p>然后我的 WSL2 无法启动</p><figure><img src="error2.png" alt="" /><figcaption>WSL2Error</figcaption></figure><p>随后我检查了我的系统功能配置</p><figure><img src="config.png" alt="" /><figcaption>SysConfig</figcaption></figure><p>检查了我的虚拟化配置</p><figure><img src="config2.png" alt="" /><figcaption>SysConfig2</figcaption></figure><p>他们都是正常的</p><p>重新打开关闭了他们，重启后依然遇到了这些问题，完全无法解决</p><p>非常绝望，在这个时候甚至想<code>重装</code> Windows，但是综合考虑到代价又感觉似乎太重了，还是搁置等某一天能自动解决这个问题</p><p>直到我脑子一闪想到了在 Docker 不支持 WSL2 后端时候打开 HTTP API 的方法：通过 socket 工具把数据暴露出来</p><p>或许 Docker 现在用了 WSL2 后端也依赖 socket？而且 HyperV 内的 WSL2 和外界通信也需要使用 socket？</p><p>Windows 不是 UNIX-like 系统，早就去掉了 POSIX 子系统，所以 Windows 内多半有一个 socket 管理器，那么 Windows 内部的 socket 管理器是不是被 BlueStacks 改过？</p><h2 id="醒梦">醒梦</h2><p>经过资料的查询，果然 Windows 内部为了支持 UNIX 的 Socket 和一系列其他网络协议做了 winsock，但是没有查找到相应的 BlueStack 会修改 winsock 的资料</p><p>然而我查到了 winsock 会导致 WSL2 无法工作的 issue</p><p>当然 WSL2 无法工作意味着 Docker 也无法工作</p><p><a href="https://github.com/microsoft/wsl/issues/4177">Winsock module breaks WSL2</a></p><p>经过推测，没办法得出结论，只能死马当活马医了</p><p>在这个 issue 里面我发现了这么<a href="https://github.com/microsoft/wsl/issues/4177#issuecomment-635924671">一条</a></p><blockquote><p>i cannot use WSL 2 and proxifier at the same time, netsh winsock reset will fix it temporarily.</p></blockquote><p>同时在这里有一个<a href="https://github.com/docker/for-win/issues/7164">跳转</a>，跳转到 Docker 的项目，在这里它提到了一条很重要的信息</p><blockquote><p>there was a bug with microsoft/WSL#4177</p></blockquote><p>想必就是 WSL2 的问题了，我回去继续看解决方法。</p><p>但是 issue 中其他回复对我是无用的，所以我只找到了这一条大概是有效的命令</p><figure class="highlight pwsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pwsh">netsh winsock reset<br></code></pre></td></tr></table></figure><p>字面上看，重置 netsh 服务当中的 winsock。</p><p>事实证明它成功了，我的 WSL2 又活了过来，Docker 也正常工作了</p><h2 id="总结">总结</h2><p>虽然搞的莫名其妙，噩梦的非常莫名其妙，修好系统也是莫名其妙，但是总归是修好了。</p><p>还好有一点 Docker 可能和 socket 相关的记忆，让我想到了 Docker 启动失败是否和 socket 有关，抓住了一点点线索完成了修复</p><p>另外现在好像也没有 HyperV 兼容的安卓模拟器，真难过</p>]]></content>
    
    
    <categories>
      
      <category>捣鼓</category>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
